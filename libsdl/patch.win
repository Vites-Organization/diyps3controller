--- SDL-1.2.14_orig/configure	2009-10-17 19:35:13 +0200
+++ SDL-1.2.14/configure	2012-12-19 15:56:35 +0100
@@ -27786,6 +27786,7 @@
 
         SOURCES="$SOURCES $srcdir/src/video/wincommon/*.c"
         SOURCES="$SOURCES $srcdir/src/video/windib/*.c"
+        SOURCES="$SOURCES $srcdir/src/video/winmm/*.c"
         have_video=yes
     fi
 }
diff -uNr SDL-1.2.14_orig/include/SDL_events.h SDL-1.2.14/include/SDL_events.h
--- SDL-1.2.14_orig/include/SDL_events.h	2009-10-12 14:07:20 +0000
+++ SDL-1.2.14/include/SDL_events.h	2011-10-14 18:30:02 +0000
@@ -138,6 +138,7 @@
 	Uint16 x, y;	/**< The X/Y coordinates of the mouse */
 	Sint16 xrel;	/**< The relative motion in the X direction */
 	Sint16 yrel;	/**< The relative motion in the Y direction */
+	Uint32 timestamp; /* matlo */
 } SDL_MouseMotionEvent;
 
 /** Mouse button event structure */
@@ -347,6 +348,9 @@
 */
 extern DECLSPEC Uint8 SDLCALL SDL_EventState(Uint8 type, int state);
 
+extern DECLSPEC const char* SDLCALL SDL_GetMouseName(int id);
+extern DECLSPEC const char* SDLCALL SDL_GetKeyboardName(int id);
+
 /* Ends C function definitions when using C++ */
 #ifdef __cplusplus
 }
diff -uNr SDL-1.2.14_orig/include/SDL_mouse.h SDL-1.2.14/include/SDL_mouse.h
--- SDL-1.2.14_orig/include/SDL_mouse.h	2009-10-13 01:07:19 +0200
+++ SDL-1.2.14/include/SDL_mouse.h	2012-11-08 10:15:52 +0100
@@ -127,6 +127,8 @@
 #define SDL_BUTTON_WHEELDOWN	5
 #define SDL_BUTTON_X1		6
 #define SDL_BUTTON_X2		7
+#define SDL_BUTTON_X3		8
+#define SDL_BUTTON_X4		9
 #define SDL_BUTTON_LMASK	SDL_BUTTON(SDL_BUTTON_LEFT)
 #define SDL_BUTTON_MMASK	SDL_BUTTON(SDL_BUTTON_MIDDLE)
 #define SDL_BUTTON_RMASK	SDL_BUTTON(SDL_BUTTON_RIGHT)
diff -uNr SDL-1.2.14_orig/src/events/SDL_keyboard.c SDL-1.2.14/src/events/SDL_keyboard.c
--- SDL-1.2.14_orig/src/events/SDL_keyboard.c	2009-10-12 14:07:14 +0000
+++ SDL-1.2.14/src/events/SDL_keyboard.c	2011-10-27 18:58:10 +0000
@@ -395,6 +395,8 @@
 	return (char *)(keyname);
 }
 
+Uint8 keyboard_id; /* Matlo */
+
 /* These are global for SDL_eventloop.c */
 int SDL_PrivateKeyboard(Uint8 state, SDL_keysym *keysym)
 {
@@ -404,6 +406,8 @@
 
 	SDL_memset(&event, 0, sizeof(event));
 
+	event.key.which = keyboard_id; /* Matlo */
+
 #if 0
 printf("The '%s' key has been %s\n", SDL_GetKeyName(keysym->sym), 
 				state == SDL_PRESSED ? "pressed" : "released");
@@ -419,20 +423,12 @@
 			case SDLK_UNKNOWN:
 				break;
 			case SDLK_NUMLOCK:
-				modstate ^= KMOD_NUM;
-				if ( SDL_NoLockKeys & SDL_NLK_NUM )
-					break;
-				if ( ! (modstate&KMOD_NUM) )
-					state = SDL_RELEASED;
-				keysym->mod = (SDLMod)modstate;
+			  //Matlo
+				modstate |= KMOD_NUM;
 				break;
 			case SDLK_CAPSLOCK:
-				modstate ^= KMOD_CAPS;
-				if ( SDL_NoLockKeys & SDL_NLK_CAPS )
-					break;
-				if ( ! (modstate&KMOD_CAPS) )
-					state = SDL_RELEASED;
-				keysym->mod = (SDLMod)modstate;
+			  //Matlo
+				modstate |= KMOD_CAPS;
 				break;
 			case SDLK_LCTRL:
 				modstate |= KMOD_LCTRL;
@@ -470,15 +466,13 @@
 			case SDLK_UNKNOWN:
 				break;
 			case SDLK_NUMLOCK:
-				if ( SDL_NoLockKeys & SDL_NLK_NUM )
-					break;
-				/* Only send keydown events */
-				return(0);
+        //Matlo
+        modstate &= ~KMOD_NUM;
+        break;
 			case SDLK_CAPSLOCK:
-				if ( SDL_NoLockKeys & SDL_NLK_CAPS )
-					break;
-				/* Only send keydown events */
-				return(0);
+        //Matlo
+        modstate &= ~KMOD_CAPS;
+        break;
 			case SDLK_LCTRL:
 				modstate &= ~KMOD_LCTRL;
 				break;
@@ -533,13 +527,14 @@
 	}
 
 	if ( keysym->sym != SDLK_UNKNOWN ) {
-		/* Drop events that don't change state */
-		if ( SDL_KeyState[keysym->sym] == state ) {
-#if 0
-printf("Keyboard event didn't change state - dropped!\n");
-#endif
-			return(0);
-		}
+// Matlo
+//		/* Drop events that don't change state */
+//		if ( SDL_KeyState[keysym->sym] == state ) {
+//#if 0
+//printf("Keyboard event didn't change state - dropped!\n");
+//#endif
+//			return(0);
+//		}
 
 		/* Update internal keyboard state */
 		SDL_ModState = (SDLMod)modstate;
diff -uNr SDL-1.2.14_orig/src/events/SDL_mouse.c SDL-1.2.14/src/events/SDL_mouse.c
--- SDL-1.2.14_orig/src/events/SDL_mouse.c	2009-10-12 14:07:14 +0000
+++ SDL-1.2.14/src/events/SDL_mouse.c	2011-10-27 18:57:45 +0000
@@ -109,6 +109,10 @@
 	SDL_MouseMaxY = (Sint16)maxY;
 }
 
+//Matlo
+Uint8 mouse_id;
+Uint32 timestamp;
+
 /* These are global for SDL_eventloop.c */
 int SDL_PrivateMouseMotion(Uint8 buttonstate, int relative, Sint16 x, Sint16 y)
 {
@@ -180,6 +184,8 @@
 	if ( SDL_ProcessEvents[SDL_MOUSEMOTION] == SDL_ENABLE ) {
 		SDL_Event event;
 		SDL_memset(&event, 0, sizeof(event));
+		event.motion.which = mouse_id; //Matlo
+		event.motion.timestamp = timestamp;
 		event.type = SDL_MOUSEMOTION;
 		event.motion.state = buttonstate;
 		event.motion.x = X;
@@ -203,6 +209,7 @@
 
 	SDL_memset(&event, 0, sizeof(event));
 
+	event.motion.which = mouse_id; //Matlo
 	/* Check parameters */
 	if ( x || y ) {
 		ClipOffset(&x, &y);
diff -uNr SDL-1.2.14_orig/src/video/bwindow/SDL_sysevents.cc SDL-1.2.14/src/video/bwindow/SDL_sysevents.cc
--- SDL-1.2.14_orig/src/video/bwindow/SDL_sysevents.cc	2009-10-12 14:07:16 +0000
+++ SDL-1.2.14/src/video/bwindow/SDL_sysevents.cc	2011-10-29 14:48:30 +0000
@@ -160,149 +160,150 @@
 void SDL_BWin::DispatchMessage(BMessage *msg, BHandler *target)
 {
 	switch (msg->what) {
-		case B_MOUSE_MOVED:
-		{
-			SDL_VideoDevice *view = current_video;
-			BPoint where;
-			int32 transit;
-			if (msg->FindPoint("where", &where) == B_OK && msg->FindInt32("be:transit", &transit) == B_OK) {
-				int x, y;
-
-				GetXYOffset(x, y);
-				x = (int)where.x - x;
-				y = (int)where.y - y;
-
-				//BeSman: I need another method for cursor catching !!!
-				if (view->input_grab != SDL_GRAB_OFF)
-				{
-					bool clipped = false;
-					if ( x < 0 ) {
-						x = 0;
-						clipped = true;
-					} else if ( x >= SDL_VideoSurface->w ) {
-						x = (SDL_VideoSurface->w-1);
-						clipped = true;
-					}
-					if ( y < 0 ) {
-						y = 0;
-						clipped = true;
-					} else if ( y >= SDL_VideoSurface->h ) {
-						y = (SDL_VideoSurface->h-1);
-						clipped = true;
-					}
-					if ( clipped ) {
-						BPoint edge;
-						GetXYOffset(edge.x, edge.y);
-						edge.x += x;
-						edge.y += y;
-						ConvertToScreen(&edge);
-						set_mouse_position((int)edge.x, (int)edge.y);
-					}
-					transit = B_INSIDE_VIEW;
-				}
-				if (transit == B_EXITED_VIEW) {
-					if ( SDL_GetAppState() & SDL_APPMOUSEFOCUS ) {
-						SDL_PrivateAppActive(0, SDL_APPMOUSEFOCUS);
-						be_app->SetCursor(B_HAND_CURSOR);
-					}
-				} else {
-					if ( !(SDL_GetAppState() & SDL_APPMOUSEFOCUS) ) {
-						SDL_PrivateAppActive(1, SDL_APPMOUSEFOCUS);
-						SDL_SetCursor(NULL);
-					}
-
-					if ( mouse_relative ) {
-						int half_w = (SDL_VideoSurface->w/2);
-						int half_h = (SDL_VideoSurface->h/2);
-						x -= half_w;
-						y -= half_h;
-						if ( x || y ) {
-							BPoint center;
-							GetXYOffset(center.x, center.y);
-							center.x += half_w;
-							center.y += half_h;
-							ConvertToScreen(&center);
-							set_mouse_position((int)center.x, (int)center.y);
-							SDL_PrivateMouseMotion(0, 1, x, y);
-						}
-					} else {
-						SDL_PrivateMouseMotion(0, 0, x, y);
-					}
-				}
-			}
-			break;
-		}
-
-		case B_MOUSE_DOWN:
-		{
-			/*	it looks like mouse down is send only for first clicked
-				button, each next is not send while last one is holded */
-			int32 buttons;
-			int sdl_buttons = 0;
-			if (msg->FindInt32("buttons", &buttons) == B_OK) {
-				/* Add any mouse button events */
-				if (buttons & B_PRIMARY_MOUSE_BUTTON) {
-					sdl_buttons |= SDL_BUTTON_LEFT;
-				}
-				if (buttons & B_SECONDARY_MOUSE_BUTTON) {
-					sdl_buttons |= SDL_BUTTON_RIGHT;
-				}
-				if (buttons & B_TERTIARY_MOUSE_BUTTON) {
-					sdl_buttons |= SDL_BUTTON_MIDDLE;
-				}
-				SDL_PrivateMouseButton(SDL_PRESSED, sdl_buttons, 0, 0);
-
-				last_buttons = buttons;
-			}
-			break;
-		}
-
-		case B_MOUSE_UP:
-		{
-			/*	mouse up doesn't give which button was released,
-				only state of buttons (after release, so it's always = 0),
-				which is not what we need ;]
-				So we need to store button in mouse down, and restore
-				in mouse up :(
-				mouse up is (similarly to mouse down) send only for
-				first button down (ie. it's no send if we click another button
-				without releasing previous one first) - but that's probably
-				because of how drivers are written?, not BeOS itself. */
-			int32 buttons;
-			int sdl_buttons = 0;
-			if (msg->FindInt32("buttons", &buttons) == B_OK) {
-				/* Add any mouse button events */
-				if ((buttons ^ B_PRIMARY_MOUSE_BUTTON) & last_buttons) {
-					sdl_buttons |= SDL_BUTTON_LEFT;
-				}
-				if ((buttons ^ B_SECONDARY_MOUSE_BUTTON) & last_buttons) {
-					sdl_buttons |= SDL_BUTTON_RIGHT;
-				}
-				if ((buttons ^ B_TERTIARY_MOUSE_BUTTON) & last_buttons) {
-					sdl_buttons |= SDL_BUTTON_MIDDLE;
-				}
-				SDL_PrivateMouseButton(SDL_RELEASED, sdl_buttons, 0, 0);
-
-				last_buttons = buttons;
-			}
-			break;
-		}
-
-		case B_MOUSE_WHEEL_CHANGED:
-		{
-			float x, y;
-			x = y = 0;
-			if (msg->FindFloat("be:wheel_delta_x", &x) == B_OK && msg->FindFloat("be:wheel_delta_y", &y) == B_OK) {
-				if (x < 0 || y < 0) {
-					SDL_PrivateMouseButton(SDL_PRESSED, SDL_BUTTON_WHEELDOWN, 0, 0);
-					SDL_PrivateMouseButton(SDL_RELEASED, SDL_BUTTON_WHEELDOWN, 0, 0);
-				} else if (x > 0 || y > 0) {
-					SDL_PrivateMouseButton(SDL_PRESSED, SDL_BUTTON_WHEELUP, 0, 0);
-					SDL_PrivateMouseButton(SDL_RELEASED, SDL_BUTTON_WHEELUP, 0, 0);
-				}
-			}
-			break;
-		}
+//Matlo
+//		case B_MOUSE_MOVED:
+//		{
+//			SDL_VideoDevice *view = current_video;
+//			BPoint where;
+//			int32 transit;
+//			if (msg->FindPoint("where", &where) == B_OK && msg->FindInt32("be:transit", &transit) == B_OK) {
+//				int x, y;
+//
+//				GetXYOffset(x, y);
+//				x = (int)where.x - x;
+//				y = (int)where.y - y;
+//
+//				//BeSman: I need another method for cursor catching !!!
+//				if (view->input_grab != SDL_GRAB_OFF)
+//				{
+//					bool clipped = false;
+//					if ( x < 0 ) {
+//						x = 0;
+//						clipped = true;
+//					} else if ( x >= SDL_VideoSurface->w ) {
+//						x = (SDL_VideoSurface->w-1);
+//						clipped = true;
+//					}
+//					if ( y < 0 ) {
+//						y = 0;
+//						clipped = true;
+//					} else if ( y >= SDL_VideoSurface->h ) {
+//						y = (SDL_VideoSurface->h-1);
+//						clipped = true;
+//					}
+//					if ( clipped ) {
+//						BPoint edge;
+//						GetXYOffset(edge.x, edge.y);
+//						edge.x += x;
+//						edge.y += y;
+//						ConvertToScreen(&edge);
+//						set_mouse_position((int)edge.x, (int)edge.y);
+//					}
+//					transit = B_INSIDE_VIEW;
+//				}
+//				if (transit == B_EXITED_VIEW) {
+//					if ( SDL_GetAppState() & SDL_APPMOUSEFOCUS ) {
+//						SDL_PrivateAppActive(0, SDL_APPMOUSEFOCUS);
+//						be_app->SetCursor(B_HAND_CURSOR);
+//					}
+//				} else {
+//					if ( !(SDL_GetAppState() & SDL_APPMOUSEFOCUS) ) {
+//						SDL_PrivateAppActive(1, SDL_APPMOUSEFOCUS);
+//						SDL_SetCursor(NULL);
+//					}
+//
+//					if ( mouse_relative ) {
+//						int half_w = (SDL_VideoSurface->w/2);
+//						int half_h = (SDL_VideoSurface->h/2);
+//						x -= half_w;
+//						y -= half_h;
+//						if ( x || y ) {
+//							BPoint center;
+//							GetXYOffset(center.x, center.y);
+//							center.x += half_w;
+//							center.y += half_h;
+//							ConvertToScreen(&center);
+//							set_mouse_position((int)center.x, (int)center.y);
+//							SDL_PrivateMouseMotion(0, 1, x, y);
+//						}
+//					} else {
+//						SDL_PrivateMouseMotion(0, 0, x, y);
+//					}
+//				}
+//			}
+//			break;
+//		}
+//
+//		case B_MOUSE_DOWN:
+//		{
+//			/*	it looks like mouse down is send only for first clicked
+//				button, each next is not send while last one is holded */
+//			int32 buttons;
+//			int sdl_buttons = 0;
+//			if (msg->FindInt32("buttons", &buttons) == B_OK) {
+//				/* Add any mouse button events */
+//				if (buttons & B_PRIMARY_MOUSE_BUTTON) {
+//					sdl_buttons |= SDL_BUTTON_LEFT;
+//				}
+//				if (buttons & B_SECONDARY_MOUSE_BUTTON) {
+//					sdl_buttons |= SDL_BUTTON_RIGHT;
+//				}
+//				if (buttons & B_TERTIARY_MOUSE_BUTTON) {
+//					sdl_buttons |= SDL_BUTTON_MIDDLE;
+//				}
+//				SDL_PrivateMouseButton(SDL_PRESSED, sdl_buttons, 0, 0);
+//
+//				last_buttons = buttons;
+//			}
+//			break;
+//		}
+//
+//		case B_MOUSE_UP:
+//		{
+//			/*	mouse up doesn't give which button was released,
+//				only state of buttons (after release, so it's always = 0),
+//				which is not what we need ;]
+//				So we need to store button in mouse down, and restore
+//				in mouse up :(
+//				mouse up is (similarly to mouse down) send only for
+//				first button down (ie. it's no send if we click another button
+//				without releasing previous one first) - but that's probably
+//				because of how drivers are written?, not BeOS itself. */
+//			int32 buttons;
+//			int sdl_buttons = 0;
+//			if (msg->FindInt32("buttons", &buttons) == B_OK) {
+//				/* Add any mouse button events */
+//				if ((buttons ^ B_PRIMARY_MOUSE_BUTTON) & last_buttons) {
+//					sdl_buttons |= SDL_BUTTON_LEFT;
+//				}
+//				if ((buttons ^ B_SECONDARY_MOUSE_BUTTON) & last_buttons) {
+//					sdl_buttons |= SDL_BUTTON_RIGHT;
+//				}
+//				if ((buttons ^ B_TERTIARY_MOUSE_BUTTON) & last_buttons) {
+//					sdl_buttons |= SDL_BUTTON_MIDDLE;
+//				}
+//				SDL_PrivateMouseButton(SDL_RELEASED, sdl_buttons, 0, 0);
+//
+//				last_buttons = buttons;
+//			}
+//			break;
+//		}
+//
+//		case B_MOUSE_WHEEL_CHANGED:
+//		{
+//			float x, y;
+//			x = y = 0;
+//			if (msg->FindFloat("be:wheel_delta_x", &x) == B_OK && msg->FindFloat("be:wheel_delta_y", &y) == B_OK) {
+//				if (x < 0 || y < 0) {
+//					SDL_PrivateMouseButton(SDL_PRESSED, SDL_BUTTON_WHEELDOWN, 0, 0);
+//					SDL_PrivateMouseButton(SDL_RELEASED, SDL_BUTTON_WHEELDOWN, 0, 0);
+//				} else if (x > 0 || y > 0) {
+//					SDL_PrivateMouseButton(SDL_PRESSED, SDL_BUTTON_WHEELUP, 0, 0);
+//					SDL_PrivateMouseButton(SDL_RELEASED, SDL_BUTTON_WHEELUP, 0, 0);
+//				}
+//			}
+//			break;
+//		}
 
 		case B_KEY_DOWN:
 		case B_UNMAPPED_KEY_DOWN: /* modifier keys are unmapped */
diff -uNr SDL-1.2.14_orig/src/video/windib/SDL_dibevents.c SDL-1.2.14/src/video/windib/SDL_dibevents.c
--- SDL-1.2.14_orig/src/video/windib/SDL_dibevents.c	2009-10-17 07:59:12 +0000
+++ SDL-1.2.14/src/video/windib/SDL_dibevents.c	2011-11-03 19:36:15 +0000
@@ -33,6 +33,9 @@
 #include "SDL_gapidibvideo.h"
 #include "SDL_vkeys.h"
 
+//Matlo
+#include "../winmm/manymouse.h"
+
 #ifdef SDL_VIDEO_DRIVER_GAPI
 #include "../gapi/SDL_gapivideo.h"
 #endif
@@ -357,6 +360,10 @@
 	}
 }
 
+/* Matlo */
+extern Uint8 mouse_id;
+extern Uint8 keyboard_id;
+
 void DIB_PumpEvents(_THIS)
 {
 	MSG msg;
@@ -368,8 +375,81 @@
 		}
 	}
 
-	if ( SDL_GetAppState() & SDL_APPMOUSEFOCUS ) {
+  //Matlo
+	/*if ( SDL_GetAppState() & SDL_APPMOUSEFOCUS ) {
 		DIB_GenerateMouseMotionEvent( this );
+	}*/
+
+	ManyMouseEvent event;
+	short x = 0;
+	short y = 0;
+	Uint8 button = 0;
+	int pressed;
+
+	while (ManyMouse_PollEvent(&event))
+  {
+	    mouse_id = event.device;
+
+      if (event.type == MANYMOUSE_EVENT_RELMOTION)
+      {
+          if(event.item == 0)
+          {
+              x+=event.value;
+          }
+          else
+          {
+              y+=event.value;
+          }
+      }
+
+      else if (event.type == MANYMOUSE_EVENT_BUTTON)
+      {
+          switch(event.item)
+          {
+            case 0:
+              button = SDL_BUTTON_LEFT;
+              break;
+            case 1:
+              button = SDL_BUTTON_RIGHT;
+              break;
+            case 2:
+              button = SDL_BUTTON_MIDDLE;
+              break;
+            case 3:
+              button = SDL_BUTTON_X1;
+              break;
+            case 4:
+              button = SDL_BUTTON_X2;
+              break;
+          }
+          SDL_PrivateMouseButton(event.value ? SDL_PRESSED : SDL_RELEASED, button, 0, 0);
+      }
+
+      else if (event.type == MANYMOUSE_EVENT_SCROLL)
+      {
+	      if(event.item == 0)
+		  {
+            SDL_PrivateMouseButton(SDL_PRESSED, (event.value > 0) ? SDL_BUTTON_WHEELUP : SDL_BUTTON_WHEELDOWN, 0, 0);
+            SDL_PrivateMouseButton(SDL_RELEASED, (event.value > 0) ? SDL_BUTTON_WHEELUP : SDL_BUTTON_WHEELDOWN, 0, 0);
+	      }
+		  else
+		  {
+		    SDL_PrivateMouseButton(SDL_PRESSED, (event.value < 0) ? SDL_BUTTON_X3 : SDL_BUTTON_X4, 0, 0);
+		    SDL_PrivateMouseButton(SDL_RELEASED, (event.value < 0) ? SDL_BUTTON_X3 : SDL_BUTTON_X4, 0, 0);
+		  }
+      }
+
+      else if(event.type == MANYMOUSE_EVENT_KEY)
+      {
+        keyboard_id = event.device;
+        pressed = event.value ? SDL_PRESSED : SDL_RELEASED;
+        DIB_HandleMessage(current_video, SDL_Window, event.value ? WM_KEYDOWN : WM_KEYUP, event.item, event.scancode);
+      }
+  }
+
+	if(x || y)
+	{
+	    SDL_PrivateMouseMotion(0, 1, (Sint16)x, (Sint16)y);
 	}
 }
 
@@ -676,6 +756,10 @@
 			SDL_SetError("Couldn't create window");
 			return(-1);
 		}
+
+	  //Matlo
+	  ManyMouse_Init();
+
 		ShowWindow(SDL_Window, SW_HIDE);
 	}
 
@@ -703,3 +787,17 @@
 	*/
 	WIN_FlushMessageQueue();
 }
+
+//Matlo
+static char keyboardName[256] = {};
+static char mouseName[256] = {};
+
+const char* SDL_GetKeyboardName(int id)
+{
+  return ManyMouse_KeyboardName(id);
+}
+
+const char* SDL_GetMouseName(int id)
+{
+  return ManyMouse_MouseName(id);
+}
diff -uNr SDL-1.2.14_orig/src/video/windib/SDL_dibvideo.c SDL-1.2.14/src/video/windib/SDL_dibvideo.c
--- SDL-1.2.14_orig/src/video/windib/SDL_dibvideo.c	2009-10-16 22:45:42 +0000
+++ SDL-1.2.14/src/video/windib/SDL_dibvideo.c	2011-10-26 11:26:35 +0000
@@ -41,6 +41,9 @@
 #include "SDL_dibevents_c.h"
 #include "../wincommon/SDL_wingl_c.h"
 
+//Matlo
+#include "../winmm/manymouse.h"
+
 #ifdef _WIN32_WCE
 
 #ifndef DM_DISPLAYORIENTATION
@@ -1236,6 +1239,9 @@
 		SDL_modelist[i] = NULL;
 		SDL_nummodes[i] = 0;
 	}
+
+	//Matlo
+	ManyMouse_Quit();
 }
 
 /* Exported for the windows message loop only */
diff -uNr SDL-1.2.14_orig/src/video/winmm/manymouse.c SDL-1.2.14/src/video/winmm/manymouse.c
--- SDL-1.2.14_orig/src/video/winmm/manymouse.c	1970-01-01 00:00:00 +0000
+++ SDL-1.2.14/src/video/winmm/manymouse.c	2011-10-17 17:32:04 +0000
@@ -0,0 +1,97 @@
+/*
+ * ManyMouse foundation code; apps talks to this and it talks to the lowlevel
+ *  code for various platforms.
+ *
+ * Please see the file LICENSE.txt in the source's root directory.
+ *
+ *  This file written by Ryan C. Gordon.
+ */
+
+#include <stdlib.h>
+#include "manymouse.h"
+
+static const char *manymouse_copyright =
+    "ManyMouse " MANYMOUSE_VERSION " copyright (c) 2005-2008 Ryan C. Gordon.";
+
+extern const ManyMouseDriver *ManyMouseDriver_windows;
+
+/*
+ * These have to be in the favored order...obviously it doesn't matter if the
+ *  Linux driver comes before or after the Windows one, since one won't
+ *  exist on a given platform, but things like Mac OS X's hidmanager (which
+ *  only works on OS X 10.5 and later) should come before Mac OS X's
+ *  hidutilities (which works on older systems, but may stop working in 10.6
+ *  and later). In the Mac OS X case, you want to try the newer tech, and if
+ *  it's not available (on 10.4 or earlier), fall back to trying the legacy
+ *  code.
+ */
+static const ManyMouseDriver **mice_drivers[] =
+{
+    &ManyMouseDriver_windows,
+};
+
+
+static const ManyMouseDriver *driver = NULL;
+
+int ManyMouse_Init(void)
+{
+    const int upper = (sizeof (mice_drivers) / sizeof (mice_drivers[0]));
+    int i;
+    int retval = -1;
+
+    /* impossible test to keep manymouse_copyright linked into the binary. */
+    if (manymouse_copyright == NULL)
+        return -1;
+
+    if (driver != NULL)
+        return -1;
+
+    for (i = 0; (i < upper) && (driver == NULL); i++)
+    {
+        const ManyMouseDriver *this_driver = *(mice_drivers[i]);
+        if (this_driver != NULL) /* if not built for this platform, skip it. */
+        {
+            const int mice = this_driver->init();
+            if (mice > retval)
+                retval = mice; /* may move from "error" to "no mice found". */
+
+            if (mice > 0)
+                driver = this_driver;
+        } /* if */
+    } /* for */
+
+    return retval;
+} /* ManyMouse_Init */
+
+
+void ManyMouse_Quit(void)
+{
+    if (driver != NULL)
+    {
+        driver->quit();
+        driver = NULL;
+    } /* if */
+} /* ManyMouse_Quit */
+
+const char *ManyMouse_DriverName(void)
+{
+    return (driver) ? driver->driver_name : NULL;
+} /* ManyMouse_DriverName */
+
+const char *ManyMouse_MouseName(unsigned int index)
+{
+    return (driver) ? driver->mouse_name(index) : NULL;
+} /* ManyMouse_DeviceName */
+
+const char *ManyMouse_KeyboardName(unsigned int index)
+{
+    return (driver) ? driver->keyboard_name(index) : NULL;
+} /* ManyMouse_DeviceName */
+
+int ManyMouse_PollEvent(ManyMouseEvent *event)
+{
+    return (driver) ? driver->poll(event) : 0;
+} /* ManyMouse_PollEvent */
+
+/* end of manymouse.c ... */
+
diff -uNr SDL-1.2.14_orig/src/video/winmm/manymouse.h SDL-1.2.14/src/video/winmm/manymouse.h
--- SDL-1.2.14_orig/src/video/winmm/manymouse.h	1970-01-01 00:00:00 +0000
+++ SDL-1.2.14/src/video/winmm/manymouse.h	2011-10-27 16:43:09 +0000
@@ -0,0 +1,67 @@
+/*
+ * ManyMouse main header. Include this from your app.
+ *
+ * Please see the file LICENSE.txt in the source's root directory.
+ *
+ *  This file written by Ryan C. Gordon.
+ */
+
+#ifndef _INCLUDE_MANYMOUSE_H_
+#define _INCLUDE_MANYMOUSE_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MANYMOUSE_VERSION "0.0.3"
+
+typedef enum
+{
+    MANYMOUSE_EVENT_ABSMOTION = 0,
+    MANYMOUSE_EVENT_RELMOTION,
+    MANYMOUSE_EVENT_BUTTON,
+    MANYMOUSE_EVENT_SCROLL,
+    MANYMOUSE_EVENT_DISCONNECT,
+    MANYMOUSE_EVENT_KEY,
+    MANYMOUSE_EVENT_MAX
+} ManyMouseEventType;
+
+typedef struct
+{
+    ManyMouseEventType type;
+    unsigned int device;
+    unsigned int item;
+    int value;
+    unsigned int scancode;
+    int minval;
+    int maxval;
+} ManyMouseEvent;
+
+
+/* internal use only. */
+typedef struct
+{
+    const char *driver_name;
+    int (*init)(void);
+    void (*quit)(void);
+    const char *(*mouse_name)(unsigned int index);
+    int (*poll)(ManyMouseEvent *event);
+    const char *(*keyboard_name)(unsigned int index);
+} ManyMouseDriver;
+
+
+int ManyMouse_Init(void);
+const char *ManyMouse_DriverName(void);
+void ManyMouse_Quit(void);
+const char *ManyMouse_MouseName(unsigned int index);
+int ManyMouse_PollEvent(ManyMouseEvent *event);
+const char *ManyMouse_KeyboardName(unsigned int index);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* !defined _INCLUDE_MANYMOUSE_H_ */
+
+/* end of manymouse.h ... */
+
diff -uNr SDL-1.2.14_orig/src/video/winmm/windows_wminput.c SDL-1.2.14/src/video/winmm/windows_wminput.c
--- SDL-1.2.14_orig/src/video/winmm/windows_wminput.c	1970-01-01 00:00:00 +0000
+++ SDL-1.2.14/src/video/winmm/windows_wminput.c	2011-11-03 18:57:10 +0000
@@ -0,0 +1,909 @@
+/*
+ * Support for Windows via the WM_INPUT message.
+ *
+ * Please see the file LICENSE.txt in the source's root directory.
+ *
+ *  This file written by Ryan C. Gordon.
+ */
+
+#include "manymouse.h"
+
+#if (defined(_WIN32) || defined(_WINDOWS) || defined(__CYGWIN__))
+
+/* WinUser.h won't include rawinput stuff without this... */
+#if (_WIN32_WINNT < 0x0501)
+#undef _WIN32_WINNT
+#define _WIN32_WINNT 0x0501
+#endif
+
+#define WIN32_LEAN_AND_MEAN 1
+#include <windows.h>
+#include <setupapi.h>
+#include <malloc.h>  /* needed for alloca(). */
+
+/* Cygwin's headers don't have WM_INPUT right now... */
+#ifndef WM_INPUT
+#define WM_INPUT 0x00FF
+#endif
+
+/* that should be enough, knock on wood. */
+#define MAX_DEVICES 256
+
+#define RI_MOUSE_HWHEEL 0x0800
+
+/*
+ * Just trying to avoid malloc() here...we statically allocate a buffer
+ *  for events and treat it as a ring buffer.
+ */
+/* !!! FIXME: tweak this? */
+#define MAX_EVENTS 1024
+static ManyMouseEvent input_events[MAX_EVENTS];
+static volatile int input_events_read = 0;
+static volatile int input_events_write = 0;
+static int available_mice = 0;
+static int available_keyboards = 0;
+static int did_api_lookup = 0;
+static HWND raw_hwnd = NULL;
+static const char *class_name = "ManyMouseRawInputCatcher";
+static const char *win_name = "ManyMouseRawInputMsgWindow";
+static ATOM class_atom = 0;
+static CRITICAL_SECTION mutex;
+
+typedef struct
+{
+    HANDLE handle;
+    char name[256];
+} MouseStruct;
+static MouseStruct mice[MAX_DEVICES];
+
+typedef struct
+{
+    HANDLE handle;
+    char name[256];
+} KeyboardStruct;
+static KeyboardStruct keyboards[MAX_DEVICES];
+
+
+/*
+ * The RawInput APIs only exist in Windows XP and later, so you want this
+ *  to fail gracefully on earlier systems instead of refusing to start the
+ *  process due to missing symbols. To this end, we do a symbol lookup on
+ *  User32.dll, etc to get the entry points.
+ *
+ * A lot of these are available all the way back to the start of win32 in
+ *  Windows 95 and WinNT 3.1, but just so you don't have to track down any
+ *  import libraries, I've added those here, too. That fits well with the
+ *  idea of just adding the sources to your build and going forward.
+ */
+static UINT (WINAPI *pGetRawInputDeviceList)(PRAWINPUTDEVICELIST,PUINT,UINT);
+/* !!! FIXME: use unicode version */
+static UINT (WINAPI *pGetRawInputDeviceInfoA)(HANDLE,UINT,LPVOID,PUINT);
+static BOOL (WINAPI *pRegisterRawInputDevices)(PCRAWINPUTDEVICE,UINT,UINT);
+static LRESULT (WINAPI *pDefRawInputProc)(PRAWINPUT *,INT,UINT);
+static UINT (WINAPI *pGetRawInputBuffer)(PRAWINPUT,PUINT,UINT);
+static UINT (WINAPI *pGetRawInputData)(HRAWINPUT,UINT,LPVOID,PUINT,UINT);
+static HWND (WINAPI *pCreateWindowExA)(DWORD,LPCTSTR,LPCTSTR,DWORD,int,int,int,int,HWND,HMENU,HINSTANCE,LPVOID);
+static ATOM (WINAPI *pRegisterClassExA)(CONST WNDCLASSEX *);
+static LRESULT (WINAPI *pDefWindowProcA)(HWND,UINT,WPARAM,LPARAM);
+static BOOL (WINAPI *pUnregisterClassA)(LPCTSTR,HINSTANCE);
+static HMODULE (WINAPI *pGetModuleHandleA)(LPCTSTR);
+static BOOL (WINAPI *pPeekMessageA)(LPMSG,HWND,UINT,UINT,UINT);
+static BOOL (WINAPI *pTranslateMessage)(const MSG *);
+static LRESULT (WINAPI *pDispatchMessageA)(const MSG *);
+static BOOL (WINAPI *pDestroyWindow)(HWND);
+static void (WINAPI *pInitializeCriticalSection)(LPCRITICAL_SECTION);
+static void (WINAPI *pEnterCriticalSection)(LPCRITICAL_SECTION);
+static void (WINAPI *pLeaveCriticalSection)(LPCRITICAL_SECTION);
+static void (WINAPI *pDeleteCriticalSection)(LPCRITICAL_SECTION);
+static DWORD (WINAPI *pGetLastError)(void);
+static HDEVINFO (WINAPI *pSetupDiGetClassDevsA)(LPGUID, LPCTSTR, HWND, DWORD);
+static BOOL (WINAPI *pSetupDiEnumDeviceInfo)(HDEVINFO, DWORD, PSP_DEVINFO_DATA);
+static BOOL (WINAPI *pSetupDiGetDeviceInstanceIdA)(HDEVINFO, PSP_DEVINFO_DATA, PTSTR, DWORD, PDWORD);
+static BOOL (WINAPI *pSetupDiGetDeviceRegistryPropertyA)(HDEVINFO, PSP_DEVINFO_DATA, DWORD, PDWORD, PBYTE, DWORD, PDWORD);
+static BOOL (WINAPI *pSetupDiDestroyDeviceInfoList)(HDEVINFO);
+
+static int symlookup(HMODULE dll, void **addr, const char *sym)
+{
+    *addr = GetProcAddress(dll, sym);
+    if (*addr == NULL)
+    {
+        FreeLibrary(dll);
+        return 0;
+    } /* if */
+
+    return 1;
+} /* symlookup */
+
+static int find_api_symbols(void)
+{
+    HMODULE dll;
+
+    if (did_api_lookup)
+        return 1;
+
+    #define LOOKUP(x) { if (!symlookup(dll, (void **) &p##x, #x)) return 0; }
+    dll = LoadLibrary("user32.dll");
+    if (dll == NULL)
+        return 0;
+
+    LOOKUP(GetRawInputDeviceInfoA);
+    LOOKUP(RegisterRawInputDevices);
+    LOOKUP(GetRawInputDeviceList);
+    LOOKUP(DefRawInputProc);
+    LOOKUP(GetRawInputBuffer);
+    LOOKUP(GetRawInputData);
+    LOOKUP(CreateWindowExA);
+    LOOKUP(RegisterClassExA);
+    LOOKUP(UnregisterClassA);
+    LOOKUP(DefWindowProcA);
+    LOOKUP(PeekMessageA);
+    LOOKUP(TranslateMessage);
+    LOOKUP(DispatchMessageA);
+    LOOKUP(DestroyWindow);
+
+    dll = LoadLibrary("kernel32.dll");
+    if (dll == NULL)
+        return 0;
+
+    LOOKUP(GetModuleHandleA);
+    LOOKUP(GetLastError);
+    LOOKUP(InitializeCriticalSection);
+    LOOKUP(EnterCriticalSection);
+    LOOKUP(LeaveCriticalSection);
+    LOOKUP(DeleteCriticalSection);
+
+    dll = LoadLibrary("setupapi.dll");
+    if (dll == NULL)
+        return 0;
+
+    LOOKUP(SetupDiGetClassDevsA);
+    LOOKUP(SetupDiEnumDeviceInfo);
+    LOOKUP(SetupDiGetDeviceInstanceIdA);
+    LOOKUP(SetupDiGetDeviceRegistryPropertyA);
+    LOOKUP(SetupDiDestroyDeviceInfoList);
+
+    #undef LOOKUP
+
+    did_api_lookup = 1;
+    return 1;
+} /* find_api_symbols */
+
+
+/* Some simple functions to avoid C runtime dependency... */
+
+static char make_upper(const char a)
+{
+    return ((a >= 'a') && (a <= 'z')) ? (a - ('a' - 'A')) : a;
+} /* make_upper */
+
+static void make_string_upper(char *str)
+{
+    char *ptr;
+    for (ptr = str; *ptr; ptr++)
+        *ptr = make_upper(*ptr);
+} /* make_string_upper */
+
+static int string_compare(const char *a, const char *b)
+{
+    while (1)
+    {
+        const char cha = *(a++);
+        const char chb = *(b++);
+        if (cha < chb)
+            return -1;
+        else if (cha > chb)
+            return 1;
+        else if (cha == '\0')
+            return 0;
+    } /* while */
+
+    return 0;
+} /* string_compare */
+
+static size_t string_length(const char *a)
+{
+    size_t retval;
+    for (retval = 0; *(a++); retval++) { /* spin. */ }
+    return retval;
+} /* string_length */
+
+
+static void queue_event(const ManyMouseEvent *event)
+{
+    /* copy the event info. We'll process it in ManyMouse_PollEvent(). */
+    CopyMemory(&input_events[input_events_write], event, sizeof (ManyMouseEvent));
+
+    input_events_write = ((input_events_write + 1) % MAX_EVENTS);
+
+    /* Ring buffer full? Lose oldest event. */
+    if (input_events_write == input_events_read)
+    {
+        /* !!! FIXME: we need to not lose mouse buttons here. */
+        input_events_read = ((input_events_read + 1) % MAX_EVENTS);
+    } /* if */
+} /* queue_event */
+
+#define MAPVK_VK_TO_VSC    0
+#define MAPVK_VSC_TO_VK_EX 3
+
+static void queue_from_rawinput(const RAWINPUT *raw)
+{
+    int i;
+    const RAWINPUTHEADER *header = &raw->header;
+    const RAWMOUSE *mouse = &raw->data.mouse;
+    const RAWKEYBOARD *keyboard = &raw->data.keyboard;
+    ManyMouseEvent event = {0};
+    UINT virtualKey;
+    UINT scanCode;
+    UINT flags;
+    UINT isE0;
+
+    if (raw->header.dwType == RIM_TYPEMOUSE)
+    {
+      for (i = 0; i < available_mice; i++)  /* find the device for event. */
+      {
+          if (mice[i].handle == header->hDevice)
+              break;
+      } /* for */
+
+      if (i == available_mice)
+          return;  /* not found?! */
+
+      /*
+       * RAWINPUT packs a bunch of events into one, so we split it up into
+       *  a bunch of ManyMouseEvents here and store them in an internal queue.
+       *  Then ManyMouse_PollEvent() just shuffles items off that queue
+       *  without any complicated processing.
+       */
+
+      event.device = i;
+
+      pEnterCriticalSection(&mutex);
+
+      if (mouse->usFlags & MOUSE_MOVE_ABSOLUTE)
+      {
+          /* !!! FIXME: How do we get the min and max values for absmotion? */
+          event.type = MANYMOUSE_EVENT_ABSMOTION;
+          event.item = 0;
+          event.value = mouse->lLastX;
+          queue_event(&event);
+          event.item = 1;
+          event.value = mouse->lLastY;
+          queue_event(&event);
+      } /* if */
+
+      else /*if (mouse->usFlags & MOUSE_MOVE_RELATIVE)*/
+      {
+          event.type = MANYMOUSE_EVENT_RELMOTION;
+          if (mouse->lLastX != 0)
+          {
+              event.item = 0;
+              event.value = mouse->lLastX;
+              queue_event(&event);
+          } /* if */
+
+          if (mouse->lLastY != 0)
+          {
+              event.item = 1;
+              event.value = mouse->lLastY;
+              queue_event(&event);
+          } /* if */
+      } /* else if */
+
+      event.type = MANYMOUSE_EVENT_BUTTON;
+
+      #define QUEUE_BUTTON(x) { \
+          if (mouse->usButtonFlags & RI_MOUSE_BUTTON_##x##_DOWN) { \
+              event.item = x-1; \
+              event.value = 1; \
+              queue_event(&event); \
+          } \
+          if (mouse->usButtonFlags & RI_MOUSE_BUTTON_##x##_UP) { \
+              event.item = x-1; \
+              event.value = 0; \
+              queue_event(&event); \
+          } \
+      }
+
+      QUEUE_BUTTON(1);
+      QUEUE_BUTTON(2);
+      QUEUE_BUTTON(3);
+      QUEUE_BUTTON(4);
+      QUEUE_BUTTON(5);
+
+      #undef QUEUE_BUTTON
+
+      if (mouse->usButtonFlags & RI_MOUSE_WHEEL)
+      {
+          if (mouse->usButtonData != 0)  /* !!! FIXME: can this ever be zero? */
+          {
+              event.type = MANYMOUSE_EVENT_SCROLL;
+              event.item = 0;  /* vertical wheel */
+              event.value = ( ((SHORT) mouse->usButtonData) > 0) ? 1 : -1;
+              queue_event(&event);
+          } /* if */
+      } /* if */
+	  else if (mouse->usButtonFlags & RI_MOUSE_HWHEEL)
+      {
+          if (mouse->usButtonData != 0)  /* !!! FIXME: can this ever be zero? */
+          {
+              event.type = MANYMOUSE_EVENT_SCROLL;
+              event.item = 1;  /* horizontal wheel */
+              event.value = ( ((SHORT) mouse->usButtonData) > 0) ? 1 : -1;
+              queue_event(&event);
+          } /* if */
+      } /* if */
+
+      pLeaveCriticalSection(&mutex);
+    }
+    else if(raw->header.dwType == RIM_TYPEKEYBOARD)
+    {
+      for (i = 0; i < available_keyboards; i++)  /* find the device for event. */
+      {
+          if (keyboards[i].handle == header->hDevice)
+              break;
+      } /* for */
+
+      if (i == available_keyboards)
+          return;  /* not found?! */
+
+      virtualKey = keyboard->VKey;
+      flags = keyboard->Flags;
+      scanCode = 0;
+      isE0 = flags & RI_KEY_E0;
+
+      switch (virtualKey)
+      {
+        // right-hand CONTROL and ALT have their e0 bit set
+        case VK_CONTROL:
+          if (isE0)
+            virtualKey = VK_RCONTROL;
+          else
+            virtualKey = VK_LCONTROL;
+          break;
+
+        case VK_MENU:
+          if (isE0)
+            virtualKey = VK_RMENU;
+          else
+            virtualKey = VK_LMENU;
+          break;
+
+        case VK_SHIFT:
+          if (keyboard->MakeCode == 0x36)
+            virtualKey = VK_RSHIFT;
+          else
+            virtualKey = VK_LSHIFT;
+          break;
+
+        // NUMPAD ENTER has its e0 bit set
+        case VK_RETURN:
+          if (isE0)
+            scanCode = (1 << 24);
+          break;
+
+        // the standard INSERT, DELETE, HOME, END, PRIOR and NEXT keys will always have their e0 bit set, but the
+        // corresponding keys on the NUMPAD will not.
+        case VK_INSERT:
+          if (!isE0)
+          virtualKey = VK_NUMPAD0;
+          break;
+
+        case VK_DELETE:
+          if (!isE0)
+            virtualKey = VK_DECIMAL;
+          break;
+
+        case VK_HOME:
+          if (!isE0)
+            virtualKey = VK_NUMPAD7;
+          break;
+
+        case VK_END:
+          if (!isE0)
+            virtualKey = VK_NUMPAD1;
+          break;
+
+        case VK_PRIOR:
+          if (!isE0)
+            virtualKey = VK_NUMPAD9;
+          break;
+
+        case VK_NEXT:
+          if (!isE0)
+            virtualKey = VK_NUMPAD3;
+          break;
+
+        // the standard arrow keys will always have their e0 bit set, but the
+        // corresponding keys on the NUMPAD will not.
+        case VK_LEFT:
+          if (!isE0)
+            virtualKey = VK_NUMPAD4;
+          break;
+
+        case VK_RIGHT:
+          if (!isE0)
+            virtualKey = VK_NUMPAD6;
+          break;
+
+        case VK_UP:
+          if (!isE0)
+            virtualKey = VK_NUMPAD8;
+          break;
+
+        case VK_DOWN:
+          if (!isE0)
+            virtualKey = VK_NUMPAD2;
+          break;
+
+        // NUMPAD 5 doesn't have its e0 bit set
+        case VK_CLEAR:
+          if (!isE0)
+            virtualKey = VK_NUMPAD5;
+          break;
+
+        case 0xFF:
+          return;
+      }
+
+      pEnterCriticalSection(&mutex);
+
+      event.device = i;
+      event.type = MANYMOUSE_EVENT_KEY;
+      event.item = virtualKey;
+      event.scancode = scanCode;
+
+      if(flags & RI_KEY_BREAK)
+      {
+        event.value = 0;
+      }
+      else
+      {
+        event.value = 1;
+      }
+      queue_event(&event);
+
+      pLeaveCriticalSection(&mutex);
+    }
+    else
+    {
+      return;
+    }
+
+
+} /* queue_from_rawinput */
+
+
+static void wminput_handler(WPARAM wParam, LPARAM lParam)
+{
+    UINT dwSize = 0;
+    LPBYTE lpb;
+
+    pGetRawInputData((HRAWINPUT) lParam, RID_INPUT, NULL, &dwSize,
+                      sizeof (RAWINPUTHEADER));
+
+    if (dwSize == 0)
+        return;  /* unexpected packet? */
+
+    lpb = (LPBYTE) alloca(dwSize);
+    if (lpb == NULL) 
+        return;
+    if (pGetRawInputData((HRAWINPUT) lParam, RID_INPUT, lpb, &dwSize,
+                          sizeof (RAWINPUTHEADER)) != dwSize)
+    {
+        return;
+    }
+
+    queue_from_rawinput((RAWINPUT *) lpb);
+} /* wminput_handler */
+
+
+static LRESULT CALLBACK RawWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
+{
+    if (Msg == WM_INPUT)
+        wminput_handler(wParam, lParam);
+
+    else if (Msg == WM_DESTROY)
+        return 0;
+
+    return pDefWindowProcA(hWnd, Msg, wParam, lParam);
+} /* RawWndProc */
+
+extern HWND SDL_Window;
+
+static int init_event_queue(void)
+{
+    HINSTANCE hInstance = pGetModuleHandleA(NULL);
+    WNDCLASSEX wce;
+    RAWINPUTDEVICE rid[2];
+
+    ZeroMemory(input_events, sizeof (input_events));
+    input_events_read = input_events_write = 0;
+
+    ZeroMemory(&wce, sizeof (wce));
+    wce.cbSize = sizeof(WNDCLASSEX);
+    wce.lpfnWndProc = RawWndProc;
+    wce.lpszClassName = class_name;
+    wce.hInstance = hInstance;
+    class_atom = pRegisterClassExA(&wce);
+    if (class_atom == 0)
+        return 0;
+
+    raw_hwnd = pCreateWindowExA(0, class_name, win_name, WS_OVERLAPPEDWINDOW,
+                        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
+                        CW_USEDEFAULT, HWND_MESSAGE, NULL, hInstance, NULL);
+
+    if (raw_hwnd == NULL)
+        return 0;
+
+    pInitializeCriticalSection(&mutex);
+
+    ZeroMemory(&rid[0], sizeof (rid[0]));
+    rid[0].usUsagePage = 1; /* GenericDesktop page */
+    rid[0].usUsage = 2; /* GeneralDestop Mouse usage. */
+    rid[0].dwFlags = RIDEV_INPUTSINK | RIDEV_NOLEGACY;
+    rid[0].hwndTarget = raw_hwnd;
+
+    ZeroMemory(&rid[1], sizeof (rid[1]));
+    rid[1].usUsagePage = 1;
+    rid[1].usUsage = 6;
+    rid[1].dwFlags = RIDEV_INPUTSINK | RIDEV_NOLEGACY;
+    rid[1].hwndTarget = raw_hwnd;
+
+    if (!pRegisterRawInputDevices(rid, 2, sizeof (rid[0])))
+    {
+        pDeleteCriticalSection(&mutex);
+        return 0;
+    } /* if */
+
+    return 1;
+} /* init_event_queue */
+
+
+static void cleanup_window(void)
+{
+    if (raw_hwnd)
+    {
+        MSG Msg;
+        pDestroyWindow(raw_hwnd);
+        while (pPeekMessageA(&Msg, raw_hwnd, 0, 0, PM_REMOVE))
+        {
+            pTranslateMessage(&Msg);
+            pDispatchMessageA(&Msg);
+        } /* while */
+        raw_hwnd = 0;
+    } /* if */
+
+    if (class_atom)
+    {
+        pUnregisterClassA(class_name, pGetModuleHandleA(NULL));
+        class_atom = 0;
+    } /* if */
+} /* cleanup_window */
+
+
+static int get_devinfo_data(HDEVINFO devinfo, const char *devinstance,
+                            SP_DEVINFO_DATA *data)
+{
+    DWORD i = 0;
+    const DWORD bufsize = string_length(devinstance) + 1;
+    char *buf = (char *) alloca(bufsize);
+    if (buf == NULL)
+        return 0;
+
+    while (1)
+    {
+        ZeroMemory(data, sizeof (SP_DEVINFO_DATA));
+        data->cbSize = sizeof (SP_DEVINFO_DATA);
+        if (!pSetupDiEnumDeviceInfo(devinfo, i++, data))
+        {
+            if (pGetLastError() == ERROR_NO_MORE_ITEMS)
+                break;
+            else
+                continue;
+        } /* if */
+
+        if (!pSetupDiGetDeviceInstanceIdA(devinfo, data, buf, bufsize, NULL))
+            continue;
+
+        make_string_upper(buf);
+        if (string_compare(devinstance, buf) == 0)
+            return 1;  /* found it! */
+    } /* while */
+
+    return 0;  /* not found. */
+} /* get_devinfo_data */
+
+
+static void get_dev_name_by_instance(const char *devinstance, char *name,
+                                     size_t namesize)
+{
+    SP_DEVINFO_DATA devdata;
+    const DWORD flags = DIGCF_ALLCLASSES | DIGCF_PRESENT;
+    HDEVINFO devinfo = pSetupDiGetClassDevsA(NULL, NULL, NULL, flags);
+    if (devinfo == INVALID_HANDLE_VALUE)
+        return;
+
+    if (get_devinfo_data(devinfo, devinstance, &devdata))
+    {
+        pSetupDiGetDeviceRegistryPropertyA(devinfo, &devdata, SPDRP_DEVICEDESC,
+                                           NULL, (PBYTE) name, namesize, NULL);
+    } /* if */
+
+    pSetupDiDestroyDeviceInfoList(devinfo);
+} /* get_dev_name_by_instance */
+
+
+static void get_device_product_name(char *name, size_t namesize, char *devname)
+{
+    const char default_device_name[] = "Unidentified input device";
+
+    *name = '\0';  /* really insane default. */
+    if (sizeof (default_device_name) >= namesize)
+        return;
+
+    /* in case we can't stumble upon something better... */
+    CopyMemory(name, default_device_name, sizeof (default_device_name));
+
+    /* okay, we're got the device instance. Now find the data for it. */
+    get_dev_name_by_instance(devname, name, namesize);
+} /* get_device_product_name */
+
+
+static void init_mouse(const RAWINPUTDEVICELIST *dev)
+{
+    const char rdp_ident[] = "ROOT\\RDP_MOU\\";
+    MouseStruct *mouse = &mice[available_mice];
+    KeyboardStruct *keyboard = &keyboards[available_keyboards];
+    char *buf = NULL;
+    char *ptr = NULL;
+    UINT ct = 0;
+
+    if (dev->dwType != RIM_TYPEMOUSE && dev->dwType != RIM_TYPEKEYBOARD)
+        return;  /* keyboard or some other fruity thing. */
+
+    if (pGetRawInputDeviceInfoA(dev->hDevice, RIDI_DEVICENAME, NULL, &ct) < 0)
+        return;
+
+    /* ct == is chars, not bytes, but we used the ASCII version. */
+    buf = (char *) alloca(ct+1);
+    if (buf == NULL)
+        return;
+
+    if (pGetRawInputDeviceInfoA(dev->hDevice, RIDI_DEVICENAME, buf, &ct) < 0)
+        return;
+
+    buf[ct] = '\0';  /* make sure it's null-terminated. */
+
+    /* XP starts these strings with "\\??\\" ... Vista does "\\\\?\\".  :/ */
+    while ((*buf == '?') || (*buf == '\\'))
+    {
+        buf++;
+        ct--;
+    } /* while */
+
+    /* This string tap dancing gets us the device instance id. */
+    for (ptr = buf; *ptr; ptr++)  /* convert '#' to '\\' ... */
+    {
+        char ch = *ptr;
+        if (ch == '#')
+            *ptr = '\\';
+        else if (ch == '{')  /* hit the GUID part of the string. */
+        {
+            if (*(ptr-1) == '\\')
+                ptr--;
+            break;
+        } /* else if */
+    } /* for */
+
+    *ptr = '\0';
+
+    make_string_upper(buf);
+
+    /*
+     * Apparently there's a fake "RDP" device...I guess this is
+     *  "Remote Desktop Protocol" for controlling the system pointer
+     *  remotely via Windows Remote Desktop, but that's just a guess.
+     * At any rate, we don't want that device, so skip it if detected.
+     *
+     * Idea for this found here:
+     *   http://link.mywwwserver.com/~jstookey/arcade/rawmouse/raw_mouse.c
+     */
+
+    /* avoiding memcmp here so we don't get a C runtime dependency... */
+    if (ct >= sizeof (rdp_ident) - 1)
+    {
+        int i;
+        for (i = 0; i < sizeof (rdp_ident) - 1; i++)
+        {
+            if (buf[i] != rdp_ident[i])
+                break;
+        } /* for */
+
+        if (i == sizeof (rdp_ident) - 1)
+            return;  /* this is an RDP thing. Skip this device. */
+    } /* if */
+
+    /* accept this mouse! */
+    if (dev->dwType == RIM_TYPEMOUSE)
+    {
+      ZeroMemory(mouse, sizeof (MouseStruct));
+      get_device_product_name(mouse->name, sizeof (mouse->name), buf);
+      mouse->handle = dev->hDevice;
+      available_mice++;
+    }
+    else if(dev->dwType == RIM_TYPEKEYBOARD)
+    {
+      ZeroMemory(keyboard, sizeof (KeyboardStruct));
+      get_device_product_name(keyboard->name, sizeof (keyboard->name), buf);
+      keyboard->handle = dev->hDevice;
+      available_keyboards++;
+    }
+} /* init_mouse */
+
+
+static int windows_wminput_init(void)
+{
+    RAWINPUTDEVICELIST *devlist = NULL;
+    UINT ct = 0;
+    UINT i;
+
+    available_mice = 0;
+    available_keyboards = 0;
+
+    if (!find_api_symbols())  /* only supported on WinXP and later. */
+        return -1;
+
+    pGetRawInputDeviceList(NULL, &ct, sizeof (RAWINPUTDEVICELIST));
+    if (ct == 0)  /* no devices. */
+        return 0;
+
+    devlist = (PRAWINPUTDEVICELIST) alloca(sizeof (RAWINPUTDEVICELIST) * ct);
+    pGetRawInputDeviceList(devlist, &ct, sizeof (RAWINPUTDEVICELIST));
+    for (i = 0; i < ct; i++)
+        init_mouse(&devlist[i]);
+
+    if (!init_event_queue())
+    {
+        cleanup_window();
+        available_mice = 0;
+        available_keyboards = 0;
+    } /* if */
+
+    return available_mice;
+} /* windows_wminput_init */
+
+
+static void windows_wminput_quit(void)
+{
+    /* unregister WM_INPUT devices... */
+    RAWINPUTDEVICE rid[2];
+    ZeroMemory(&rid[0], sizeof (rid[0]));
+    rid[0].usUsagePage = 1; /* GenericDesktop page */
+    rid[0].usUsage = 2; /* GeneralDestop Mouse usage. */
+    rid[0].dwFlags |= RIDEV_REMOVE;
+    ZeroMemory(&rid[1], sizeof (rid[1]));
+    rid[1].usUsagePage = 1; /* GenericDesktop page */
+    rid[1].usUsage = 6; /* GeneralDestop Keyboard usage. */
+    rid[1].dwFlags |= RIDEV_REMOVE;
+    pRegisterRawInputDevices(rid, 2, sizeof (rid[0]));
+    cleanup_window();
+    available_mice = 0;
+    available_keyboards = 0;
+    pDeleteCriticalSection(&mutex);
+} /* windows_wminput_quit */
+
+
+static const char *windows_wminput_mouse_name(unsigned int index)
+{
+    return (index < available_mice) ? mice[index].name : NULL;
+} /* windows_wminput_name */
+
+static const char *windows_wminput_keyboard_name(unsigned int index)
+{
+    return (index < available_keyboards) ? keyboards[index].name : NULL;
+} /* windows_wminput_name */
+
+
+/*
+ * Windows doesn't send a WM_INPUT event when you unplug a mouse,
+ *  so we try to do a basic query by device handle here; if the
+ *  query fails, we assume the device has vanished and generate a
+ *  disconnect.
+ */
+static int check_for_disconnects(ManyMouseEvent *ev)
+{
+    /*
+     * (i) is static so we iterate through all mice round-robin and check
+     *  one mouse per call to ManyMouse_PollEvent(). This makes this test O(1).
+     */
+    static unsigned int i = 0;
+    MouseStruct *mouse = NULL;
+
+    if (++i >= available_mice)  /* check first in case of redetect */
+        i = 0;
+
+    mouse = &mice[i];
+    if (mouse->handle != NULL)  /* not NULL == still plugged in. */
+    {
+        UINT size = 0;
+        UINT rc = pGetRawInputDeviceInfoA(mouse->handle, RIDI_DEVICEINFO,
+                                          NULL, &size);
+        if (rc == (UINT) -1)  /* failed...probably unplugged... */
+        {
+            mouse->handle = NULL;
+            ev->type = MANYMOUSE_EVENT_DISCONNECT;
+            ev->device = i;
+            return 1;
+        } /* if */
+    } /* if */
+
+    return 0;  /* no disconnect event this time. */
+} /* check_for_disconnects */
+
+
+static int windows_wminput_poll(ManyMouseEvent *ev)
+{
+    MSG Msg;  /* run the queue for WM_INPUT messages, etc ... */
+    int found = 0;
+
+    /* ...favor existing events in the queue... */
+    pEnterCriticalSection(&mutex);
+    if (input_events_read != input_events_write)  /* no events if equal. */
+    {
+        CopyMemory(ev, &input_events[input_events_read], sizeof (*ev));
+        input_events_read = ((input_events_read + 1) % MAX_EVENTS);
+        found = 1;
+    } /* if */
+    pLeaveCriticalSection(&mutex);
+
+    if (!found)
+    {
+        /* pump Windows for new hardware events... */
+        while (pPeekMessageA(&Msg, raw_hwnd, 0, 0, PM_REMOVE))
+        {
+            pTranslateMessage(&Msg);
+            pDispatchMessageA(&Msg);
+        } /* while */
+
+        /* In case something new came in, give it to the app... */
+        pEnterCriticalSection(&mutex);
+        if (input_events_read != input_events_write)  /* no events if equal. */
+        {
+            CopyMemory(ev, &input_events[input_events_read], sizeof (*ev));
+            input_events_read = ((input_events_read + 1) % MAX_EVENTS);
+            found = 1;
+        } /* if */
+        pLeaveCriticalSection(&mutex);
+    } /* if */
+
+    /*
+     * Check for disconnects if queue is totally empty and Windows didn't
+     *  report anything new at this time. This ensures that we don't send a
+     *  disconnect event through ManyMouse and then later give a valid
+     *  event to the app for a device that is now missing.
+     */
+    /*if (!found)
+        found = check_for_disconnects(ev);*/
+
+    return found;
+} /* windows_wminput_poll */
+
+static const ManyMouseDriver ManyMouseDriver_interface =
+{
+    "Windows XP and later WM_INPUT interface",
+    windows_wminput_init,
+    windows_wminput_quit,
+    windows_wminput_mouse_name,
+    windows_wminput_poll,
+    windows_wminput_keyboard_name
+};
+
+const ManyMouseDriver *ManyMouseDriver_windows = &ManyMouseDriver_interface;
+
+#else
+const ManyMouseDriver *ManyMouseDriver_windows = 0;
+#endif  /* ifdef Windows blocker */
+
+/* end of windows_wminput.c ... */
+
