diff -uNr orig//configure modif//configure
--- orig//configure	2009-10-17 19:35:13.000000000 +0200
+++ modif//configure	2011-03-30 19:45:40.377591584 +0200
@@ -4046,7 +4046,7 @@
 # if backwards compatibility has been broken,
 # set SDL_BINARY_AGE and SDL_INTERFACE_AGE to 0.
 #
-SDL_MAJOR_VERSION=1
+SDL_MAJOR_VERSION=9
 SDL_MINOR_VERSION=2
 SDL_MICRO_VERSION=14
 SDL_INTERFACE_AGE=3
diff -uNr orig//include/SDL_events.h modif//include/SDL_events.h
--- orig//include/SDL_events.h	2009-10-13 01:07:19.000000000 +0200
+++ modif//include/SDL_events.h	2011-03-30 19:28:25.962591584 +0200
@@ -138,6 +138,7 @@
 	Uint16 x, y;	/**< The X/Y coordinates of the mouse */
 	Sint16 xrel;	/**< The relative motion in the X direction */
 	Sint16 yrel;	/**< The relative motion in the Y direction */
+	Uint32 timestamp; /* matlo */
 } SDL_MouseMotionEvent;
 
 /** Mouse button event structure */
@@ -347,6 +348,10 @@
 */
 extern DECLSPEC Uint8 SDLCALL SDL_EventState(Uint8 type, int state);
 
+/* matlo */
+extern DECLSPEC const char* SDLCALL SDL_GetMouseName(int id);
+extern DECLSPEC const char* SDLCALL SDL_GetKeyboardName(int id);
+
 /* Ends C function definitions when using C++ */
 #ifdef __cplusplus
 }
diff -uNr orig//src/events/SDL_keyboard.c modif//src/events/SDL_keyboard.c
--- orig//src/events/SDL_keyboard.c	2009-10-13 01:07:14.000000000 +0200
+++ modif//src/events/SDL_keyboard.c	2011-03-23 22:13:32.428997001 +0100
@@ -395,6 +395,8 @@
 	return (char *)(keyname);
 }
 
+Uint8 keyboard_id; /* matlo */
+
 /* These are global for SDL_eventloop.c */
 int SDL_PrivateKeyboard(Uint8 state, SDL_keysym *keysym)
 {
@@ -404,6 +406,8 @@
 
 	SDL_memset(&event, 0, sizeof(event));
 
+	event.key.which = keyboard_id; /* matlo */
+
 #if 0
 printf("The '%s' key has been %s\n", SDL_GetKeyName(keysym->sym), 
 				state == SDL_PRESSED ? "pressed" : "released");
@@ -533,13 +537,14 @@
 	}
 
 	if ( keysym->sym != SDLK_UNKNOWN ) {
-		/* Drop events that don't change state */
-		if ( SDL_KeyState[keysym->sym] == state ) {
-#if 0
-printf("Keyboard event didn't change state - dropped!\n");
-#endif
-			return(0);
-		}
+/* matlo */
+//		/* Drop events that don't change state */
+//		if ( SDL_KeyState[keysym->sym] == state ) {
+//#if 0
+//printf("Keyboard event didn't change state - dropped!\n");
+//#endif
+//			return(0);
+//		}
 
 		/* Update internal keyboard state */
 		SDL_ModState = (SDLMod)modstate;
diff -uNr orig//src/events/SDL_mouse.c modif//src/events/SDL_mouse.c
--- orig//src/events/SDL_mouse.c	2009-10-13 01:07:14.000000000 +0200
+++ modif//src/events/SDL_mouse.c	2011-03-30 19:29:16.309591584 +0200
@@ -109,6 +109,10 @@
 	SDL_MouseMaxY = (Sint16)maxY;
 }
 
+/* matlo */
+Uint8 mouse_id;
+Uint32 timestamp;
+
 /* These are global for SDL_eventloop.c */
 int SDL_PrivateMouseMotion(Uint8 buttonstate, int relative, Sint16 x, Sint16 y)
 {
@@ -180,6 +184,8 @@
 	if ( SDL_ProcessEvents[SDL_MOUSEMOTION] == SDL_ENABLE ) {
 		SDL_Event event;
 		SDL_memset(&event, 0, sizeof(event));
+	  event.motion.which = mouse_id; /* matlo */
+	  event.motion.timestamp = timestamp;
 		event.type = SDL_MOUSEMOTION;
 		event.motion.state = buttonstate;
 		event.motion.x = X;
@@ -202,6 +208,8 @@
 	Uint8 buttonstate;
 
 	SDL_memset(&event, 0, sizeof(event));
+	
+  event.motion.which = mouse_id; /* matlo */
 
 	/* Check parameters */
 	if ( x || y ) {
diff -uNr orig//src/joystick/linux/SDL_sysjoystick.c modif//src/joystick/linux/SDL_sysjoystick.c
--- orig//src/joystick/linux/SDL_sysjoystick.c	2009-10-18 19:54:40.000000000 +0200
+++ modif//src/joystick/linux/SDL_sysjoystick.c	2011-04-03 16:05:25.558571502 +0200
@@ -700,7 +700,7 @@
 				continue;
 			}
 			if ( test_bit(i, absbit) ) {
-				int values[5];
+				int values[6];
 
 				if ( ioctl(fd, EVIOCGABS(i), values) < 0 )
 					continue;
diff -uNr orig//src/video/x11/SDL_x11events.c modif//src/video/x11/SDL_x11events.c
--- orig//src/video/x11/SDL_x11events.c	2009-10-13 01:07:15.000000000 +0200
+++ modif//src/video/x11/SDL_x11events.c	2011-03-30 19:30:40.280591584 +0200
@@ -34,6 +34,9 @@
 #include <sys/time.h>
 #include <unistd.h>
 
+/* matlo */
+#include <X11/extensions/XInput2.h>
+
 #include "SDL_timer.h"
 #include "SDL_syswm.h"
 #include "../SDL_sysvideo.h"
@@ -385,14 +388,89 @@
 	return(posted);
 }
 
+/* matlo */
+static int kb_id[256] = {};
+static int ms_id[256] = {};
+extern Uint8 mouse_id;
+extern Uint32 timestamp;
+extern Uint8 keyboard_id;
+extern int opcode;
+
+
 static int X11_DispatchEvent(_THIS)
 {
-	int posted;
-	XEvent xevent;
+  int posted = 0;
+  XEvent xevent;
 
 	SDL_memset(&xevent, '\0', sizeof (XEvent));  /* valgrind fix. --ryan. */
 	XNextEvent(SDL_Display, &xevent);
 
+  if (xevent.xcookie.type == GenericEvent && xevent.xcookie.extension == opcode
+      && XGetEventData(SDL_Display, &xevent.xcookie))
+  {
+    XIRawEvent *ev = xevent.xcookie.data;
+
+    switch(ev->evtype)
+    {
+      case XI_RawMotion:
+        if(ms_id[ev->deviceid] < 0) return 1;
+        mouse_id = ms_id[ev->deviceid];
+        timestamp = ev->time;
+        posted = SDL_PrivateMouseMotion(0, 1, ev->raw_values[0], ev->raw_values[1]);
+        break;
+      case XI_RawButtonPress:
+        if(ms_id[ev->deviceid] < 0) return 1;
+        mouse_id = ms_id[ev->deviceid];
+        posted = SDL_PrivateMouseButton(SDL_PRESSED, ev->detail, 0, 0);
+        break;
+      case XI_RawButtonRelease:
+        if(ms_id[ev->deviceid] < 0) return 1;
+        mouse_id = ms_id[ev->deviceid];
+        posted = SDL_PrivateMouseButton(SDL_RELEASED, ev->detail, 0, 0);
+        break;
+      case XI_RawKeyPress:
+      {
+        if(kb_id[ev->deviceid] < 0) return 1;
+        SDL_keysym keysym;
+        KeyCode keycode = ev->detail;
+        keysym.scancode = keycode;
+        keysym.sym = X11_TranslateKeycode(SDL_Display, keycode);
+        keysym.mod = KMOD_NONE;
+        keysym.unicode = 0;
+        keyboard_id = kb_id[ev->deviceid];
+        posted = SDL_PrivateKeyboard(SDL_PRESSED, &keysym);
+        break;
+      }
+      case XI_RawKeyRelease:
+      {
+        if(kb_id[ev->deviceid] < 0) return 1;
+        SDL_keysym keysym;
+        KeyCode keycode = ev->detail;
+        keysym.scancode = keycode;
+        keysym.sym = X11_TranslateKeycode(SDL_Display, keycode);
+        keysym.mod = KMOD_NONE;
+        keysym.unicode = 0;
+        keyboard_id = kb_id[ev->deviceid];
+        posted = SDL_PrivateKeyboard(SDL_RELEASED, &keysym);
+        break;
+      }
+    }
+
+    return posted;
+  }
+  else
+  {
+    switch (xevent.type)
+    {
+      case MotionNotify:
+      case ButtonPress:
+      case ButtonRelease:
+      case KeyPress:
+      case KeyRelease:
+        return 1;
+    }
+  }
+
 	/* Discard KeyRelease and KeyPress events generated by auto-repeat.
 	   We need to do it before passing event to XFilterEvent.  Otherwise,
 	   KeyRelease aware IMs are confused...  */
@@ -1394,3 +1472,71 @@
 	X11_InitKeymap();
 }
 
+/* matlo */
+extern Display* hack_dpy;
+static char keyboardName[256] = {};
+static char mouseName[256] = {};
+
+const char* SDL_GetKeyboardName(int id)
+{
+  int ndevices;
+  XIDeviceInfo *devices, *device;
+  int nb_keyboard = 0;
+
+  devices = XIQueryDevice(hack_dpy, XIAllDevices, &ndevices);
+
+  for (device = devices; device < devices + ndevices; device++)
+  {
+    switch (device->use)
+    {
+      case XISlaveKeyboard:
+        if(id == nb_keyboard)
+        {
+          strncpy(keyboardName, device->name, sizeof(keyboardName));
+          kb_id[device->deviceid] = id;
+          return keyboardName;
+        }
+        else
+        {
+          nb_keyboard++;
+        }
+        break;
+      default:
+        kb_id[device->deviceid] = -1;
+        break;
+    }
+  }
+  return NULL;
+}
+
+const char* SDL_GetMouseName(int id)
+{
+  int ndevices;
+  XIDeviceInfo *devices, *device;
+  int nb_mouse = 0;
+
+  devices = XIQueryDevice(hack_dpy, XIAllDevices, &ndevices);
+
+  for (device = devices; device < devices + ndevices; device++)
+  {
+    switch (device->use)
+    {
+      case XISlavePointer:
+        if(id == nb_mouse)
+        {
+          strncpy(mouseName, device->name, sizeof(mouseName));
+          ms_id[device->deviceid] = id;
+          return mouseName;
+        }
+        else
+        {
+          nb_mouse++;
+        }
+        break;
+      default:
+        ms_id[device->deviceid] = -1;
+        break;
+    }
+  }
+  return NULL;
+}
diff -uNr orig//src/video/x11/SDL_x11video.c modif//src/video/x11/SDL_x11video.c
--- orig//src/video/x11/SDL_x11video.c	2009-10-13 01:07:15.000000000 +0200
+++ modif//src/video/x11/SDL_x11video.c	2011-04-03 14:31:42.058798500 +0200
@@ -58,6 +58,9 @@
 #include <locale.h>
 #endif
 
+/* matlo */
+#include <X11/extensions/XInput2.h>
+
 /* Initialization/Query functions */
 static int X11_VideoInit(_THIS, SDL_PixelFormat *vformat);
 static SDL_Surface *X11_SetVideoMode(_THIS, SDL_Surface *current, int width, int height, int bpp, Uint32 flags);
@@ -315,6 +318,10 @@
 	return classname;
 }
 
+/* matlo */
+Display* hack_dpy;
+int opcode;
+
 /* Create auxiliary (toplevel) windows with the current visual */
 static void create_aux_windows(_THIS)
 {
@@ -400,10 +407,32 @@
     XFree(hints);
     X11_SetCaptionNoLock(this, this->wm_title, this->wm_icon);
 
-    app_event_mask = FocusChangeMask | KeyPressMask | KeyReleaseMask
+    app_event_mask = FocusChangeMask //matlo | KeyPressMask | KeyReleaseMask
 	| PropertyChangeMask | StructureNotifyMask | KeymapStateMask;
     XSelectInput(SDL_Display, WMwindow, app_event_mask);
 
+    /* matlo */
+    hack_dpy = SDL_Display;
+    XIEventMask eventmask;
+    eventmask.deviceid = XIAllDevices;
+    eventmask.mask_len = XIMaskLen(XI_RawMotion);
+    eventmask.mask = calloc(eventmask.mask_len, sizeof(char));
+    XISetMask(eventmask.mask, XI_RawButtonPress);
+    XISetMask(eventmask.mask, XI_RawButtonRelease);
+    XISetMask(eventmask.mask, XI_RawKeyPress);
+    XISetMask(eventmask.mask, XI_RawKeyRelease);
+    XISetMask(eventmask.mask, XI_RawMotion);
+
+    XISelectEvents(SDL_Display, DefaultRootWindow(SDL_Display), &eventmask, 1);
+
+    /* matlo */
+    int event, error;
+    if (!XQueryExtension(SDL_Display, "XInputExtension", &opcode, &event, &error))
+    {
+      printf("X Input extension not available.\n");
+      exit(-1);
+    }
+
     /* Set the class hints so we can get an icon (AfterStep) */
     get_classname(classname, sizeof(classname));
     {
@@ -1037,8 +1066,8 @@
 		/* Only manage our input if we own the window */
 		XSelectInput(SDL_Display, SDL_Window,
 					( EnterWindowMask | LeaveWindowMask
-					| ButtonPressMask | ButtonReleaseMask
-					| PointerMotionMask | ExposureMask ));
+					/* matlo | ButtonPressMask | ButtonReleaseMask
+					| PointerMotionMask*/ | ExposureMask ));
 	}
 	/* Create the graphics context here, once we have a window */
 	if ( flags & SDL_OPENGL ) {
diff -uNr orig//src/video/x11/SDL_x11wm.c modif//src/video/x11/SDL_x11wm.c
--- orig//src/video/x11/SDL_x11wm.c	2009-10-13 01:07:15.000000000 +0200
+++ modif//src/video/x11/SDL_x11wm.c	2011-04-02 22:57:26.013702001 +0200
@@ -371,7 +371,7 @@
 		/* Make sure we register input focus */
 		SDL_PrivateAppActive(1, SDL_APPINPUTFOCUS);
 		/* Since we grabbed the pointer, we have mouse focus, too. */
-		SDL_PrivateAppActive(1, SDL_APPMOUSEFOCUS);
+		//SDL_PrivateAppActive(1, SDL_APPMOUSEFOCUS);
 	}
 	XSync(SDL_Display, False);
 
