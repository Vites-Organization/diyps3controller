diff -uNr orig//include/SDL_events.h modif//include/SDL_events.h
--- orig//include/SDL_events.h	2011-03-11 00:13:20.000000000 +0100
+++ modif//include/SDL_events.h	2011-03-20 19:11:10.932462002 +0100
@@ -347,6 +347,10 @@
 */
 extern DECLSPEC Uint8 SDLCALL SDL_EventState(Uint8 type, int state);
 
+/* matlo */
+extern DECLSPEC const char* SDLCALL SDL_GetMouseName(int id);
+extern DECLSPEC const char* SDLCALL SDL_GetKeyboardName(int id);
+
 /* Ends C function definitions when using C++ */
 #ifdef __cplusplus
 }
diff -uNr orig//src/events/SDL_keyboard.c modif//src/events/SDL_keyboard.c
--- orig//src/events/SDL_keyboard.c	2011-03-11 00:13:20.000000000 +0100
+++ modif//src/events/SDL_keyboard.c	2011-03-20 19:10:36.773462002 +0100
@@ -395,6 +395,8 @@
 	return (char *)(keyname);
 }
 
+Uint8 keyboard_id; /* matlo */
+
 /* These are global for SDL_eventloop.c */
 int SDL_PrivateKeyboard(Uint8 state, SDL_keysym *keysym)
 {
@@ -404,6 +406,8 @@
 
 	SDL_memset(&event, 0, sizeof(event));
 
+	event.key.which = keyboard_id; /* matlo */
+
 #if 0
 printf("The '%s' key has been %s\n", SDL_GetKeyName(keysym->sym), 
 				state == SDL_PRESSED ? "pressed" : "released");
diff -uNr orig//src/events/SDL_mouse.c modif//src/events/SDL_mouse.c
--- orig//src/events/SDL_mouse.c	2011-03-20 19:15:02.898462002 +0100
+++ modif//src/events/SDL_mouse.c	2011-03-20 19:39:09.812462002 +0100
@@ -109,6 +109,8 @@
 	SDL_MouseMaxY = (Sint16)maxY;
 }
 
+Uint8 mouse_id; /* matlo */
+
 /* These are global for SDL_eventloop.c */
 int SDL_PrivateMouseMotion(Uint8 buttonstate, int relative, Sint16 x, Sint16 y)
 {
@@ -181,7 +183,6 @@
 		SDL_Event event;
 		SDL_memset(&event, 0, sizeof(event));
 		event.type = SDL_MOUSEMOTION;
-    event.motion.which = mouse_id; /* matlo */
 		event.motion.state = buttonstate;
 		event.motion.x = X;
 		event.motion.y = Y;
@@ -203,6 +204,8 @@
 	Uint8 buttonstate;
 
 	SDL_memset(&event, 0, sizeof(event));
+	
+  event.motion.which = mouse_id; /* matlo */
 
 	/* Check parameters */
 	if ( x || y ) {
diff -uNr orig//src/video/x11/SDL_x11events.c modif//src/video/x11/SDL_x11events.c
--- orig//src/video/x11/SDL_x11events.c	2011-03-11 00:13:18.000000000 +0100
+++ modif//src/video/x11/SDL_x11events.c	2011-03-20 19:18:12.415462002 +0100
@@ -34,6 +34,9 @@
 #include <sys/time.h>
 #include <unistd.h>
 
+/* matlo */
+#include <X11/extensions/XInput2.h>
+
 #include "SDL_timer.h"
 #include "SDL_syswm.h"
 #include "../SDL_sysvideo.h"
@@ -385,14 +388,94 @@
 	return(posted);
 }
 
+/* matlo */
+static int kb_id[256] = {};
+static int ms_id[256] = {};
+extern Uint8 mouse_id;
+extern Uint8 keyboard_id;
+
+
 static int X11_DispatchEvent(_THIS)
 {
-	int posted;
-	XEvent xevent;
+  int posted = 0;
+  XEvent xevent;
 
 	SDL_memset(&xevent, '\0', sizeof (XEvent));  /* valgrind fix. --ryan. */
 	XNextEvent(SDL_Display, &xevent);
 
+  /* matlo */
+  int opcode, event, error;
+  if (!XQueryExtension(SDL_Display, "XInputExtension", &opcode, &event, &error))
+  {
+    printf("X Input extension not available.\n");
+    return 1;
+  }
+
+  if (xevent.xcookie.type == GenericEvent && xevent.xcookie.extension == opcode
+      && XGetEventData(SDL_Display, &xevent.xcookie))
+  {
+    XIRawEvent *ev = xevent.xcookie.data;
+
+    int ndevices;
+    XIDeviceInfo* device;
+    device = XIQueryDevice(SDL_Display, ev->deviceid, &ndevices);
+    if(device && (device->use == XIMasterKeyboard || device->use == XIMasterPointer)) return 1;
+
+    switch(ev->evtype)
+    {
+      case XI_RawMotion:
+        mouse_id = ms_id[ev->deviceid];
+        posted = SDL_PrivateMouseMotion(0, 1, ev->raw_values[0], ev->raw_values[1]);
+        break;
+      case XI_RawButtonPress:
+        mouse_id = ms_id[ev->deviceid];
+        posted = SDL_PrivateMouseButton(SDL_PRESSED, ev->detail, 0, 0);
+        break;
+      case XI_RawButtonRelease:
+        mouse_id = ms_id[ev->deviceid];
+        posted = SDL_PrivateMouseButton(SDL_RELEASED, ev->detail, 0, 0);
+        break;
+      case XI_RawKeyPress:
+      {
+        SDL_keysym keysym;
+        KeyCode keycode = ev->detail;
+        keysym.scancode = keycode;
+        keysym.sym = X11_TranslateKeycode(SDL_Display, keycode);
+        keysym.mod = KMOD_NONE;
+        keysym.unicode = 0;
+        keyboard_id = kb_id[ev->deviceid];
+        posted = SDL_PrivateKeyboard(SDL_PRESSED, &keysym);
+        break;
+      }
+      case XI_RawKeyRelease:
+      {
+        SDL_keysym keysym;
+        KeyCode keycode = ev->detail;
+        keysym.scancode = keycode;
+        keysym.sym = X11_TranslateKeycode(SDL_Display, keycode);
+        keysym.mod = KMOD_NONE;
+        keysym.unicode = 0;
+        keyboard_id = kb_id[ev->deviceid];
+        posted = SDL_PrivateKeyboard(SDL_RELEASED, &keysym);
+        break;
+      }
+    }
+
+    return posted;
+  }
+  else
+  {
+    switch (xevent.type)
+    {
+      case MotionNotify:
+      case ButtonPress:
+      case ButtonRelease:
+      case KeyPress:
+      case KeyRelease:
+        return 1;
+    }
+  }
+
 	/* Discard KeyRelease and KeyPress events generated by auto-repeat.
 	   We need to do it before passing event to XFilterEvent.  Otherwise,
 	   KeyRelease aware IMs are confused...  */
@@ -1394,3 +1477,65 @@
 	X11_InitKeymap();
 }
 
+/* matlo */
+extern Display* hack_dpy;
+static char keyboardName[256] = {};
+static char mouseName[256] = {};
+
+const char* SDL_GetKeyboardName(int id)
+{
+  int ndevices;
+  XIDeviceInfo *devices, *device;
+  int nb_keyboard = 0;
+
+  devices = XIQueryDevice(hack_dpy, XIAllDevices, &ndevices);
+
+  for (device = devices; device < devices + ndevices; device++)
+  {
+    switch (device->use)
+    {
+      case XISlaveKeyboard:
+        if(id == nb_keyboard)
+        {
+          strncpy(keyboardName, device->name, sizeof(keyboardName));
+          kb_id[device->deviceid] = id;
+          return keyboardName;
+        }
+        else
+        {
+          nb_keyboard++;
+        }
+        break;
+    }
+  }
+  return NULL;
+}
+
+const char* SDL_GetMouseName(int id)
+{
+  int ndevices;
+  XIDeviceInfo *devices, *device;
+  int nb_mouse = 0;
+
+  devices = XIQueryDevice(hack_dpy, XIAllDevices, &ndevices);
+
+  for (device = devices; device < devices + ndevices; device++)
+  {
+    switch (device->use)
+    {
+      case XISlavePointer:
+        if(id == nb_mouse)
+        {
+          strncpy(mouseName, device->name, sizeof(mouseName));
+          ms_id[device->deviceid] = id;
+          return mouseName;
+        }
+        else
+        {
+          nb_mouse++;
+        }
+        break;
+    }
+  }
+  return NULL;
+}
diff -uNr orig//src/video/x11/SDL_x11video.c modif//src/video/x11/SDL_x11video.c
--- orig//src/video/x11/SDL_x11video.c	2011-03-11 00:13:18.000000000 +0100
+++ modif//src/video/x11/SDL_x11video.c	2011-03-20 19:44:01.736462002 +0100
@@ -58,6 +58,9 @@
 #include <locale.h>
 #endif
 
+/* matlo */
+#include <X11/extensions/XInput2.h>
+
 /* Initialization/Query functions */
 static int X11_VideoInit(_THIS, SDL_PixelFormat *vformat);
 static SDL_Surface *X11_SetVideoMode(_THIS, SDL_Surface *current, int width, int height, int bpp, Uint32 flags);
@@ -315,6 +318,9 @@
 	return classname;
 }
 
+/* matlo */
+Display* hack_dpy;
+
 /* Create auxiliary (toplevel) windows with the current visual */
 static void create_aux_windows(_THIS)
 {
@@ -400,10 +406,24 @@
     XFree(hints);
     X11_SetCaptionNoLock(this, this->wm_title, this->wm_icon);
 
-    app_event_mask = FocusChangeMask | KeyPressMask | KeyReleaseMask
+    app_event_mask = FocusChangeMask //matlo | KeyPressMask | KeyReleaseMask
 	| PropertyChangeMask | StructureNotifyMask | KeymapStateMask;
     XSelectInput(SDL_Display, WMwindow, app_event_mask);
 
+    /* matlo */
+    hack_dpy = SDL_Display;
+    XIEventMask eventmask;
+    eventmask.deviceid = XIAllDevices;
+    eventmask.mask_len = XIMaskLen(XI_RawMotion);
+    eventmask.mask = calloc(eventmask.mask_len, sizeof(char));
+    XISetMask(eventmask.mask, XI_RawButtonPress);
+    XISetMask(eventmask.mask, XI_RawButtonRelease);
+    XISetMask(eventmask.mask, XI_RawKeyPress);
+    XISetMask(eventmask.mask, XI_RawKeyRelease);
+    XISetMask(eventmask.mask, XI_RawMotion);
+
+    XISelectEvents(SDL_Display, DefaultRootWindow(SDL_Display), &eventmask, 1);
+
     /* Set the class hints so we can get an icon (AfterStep) */
     get_classname(classname, sizeof(classname));
     {
diff -uNr orig//src/video/x11/SDL_x11wm.c modif//src/video/x11/SDL_x11wm.c
--- orig//src/video/x11/SDL_x11wm.c	2011-03-11 00:13:18.000000000 +0100
+++ modif//src/video/x11/SDL_x11wm.c	2011-03-10 00:32:55.683378502 +0100
@@ -369,9 +369,9 @@
 			XRaiseWindow(SDL_Display, WMwindow);
 
 		/* Make sure we register input focus */
-		SDL_PrivateAppActive(1, SDL_APPINPUTFOCUS);
+		//SDL_PrivateAppActive(1, SDL_APPINPUTFOCUS);
 		/* Since we grabbed the pointer, we have mouse focus, too. */
-		SDL_PrivateAppActive(1, SDL_APPMOUSEFOCUS);
+		//SDL_PrivateAppActive(1, SDL_APPMOUSEFOCUS);
 	}
 	XSync(SDL_Display, False);
 
