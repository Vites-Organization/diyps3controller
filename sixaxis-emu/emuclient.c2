/* Sixaxis emulator

   Copyright (c) 2010 Mathieu Laurendeau

   Copyright (c) 2009 Jim Paris <jim@jtan.com>
   License: GPLv3
*/

#ifndef WIN32
#include <termio.h>
#include <sys/ioctl.h>
#include <err.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#else
#include <winsock2.h>
#define MSG_DONTWAIT 0
#endif
#include <unistd.h>
#include <fcntl.h>
#include <ctype.h>
#include <string.h>
#include <sys/types.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <SDL/SDL.h>
#include "sixaxis.h"
#include "dump.h"
#include "macros.h"
#include "config.h"
#include <math.h>

#include <pthread.h>

#define SCREEN_WIDTH  320
#define SCREEN_HEIGHT 240
#define DEFAULT_DEAD_ZONE_X 18
#define DEFAULT_DEAD_ZONE_Y 20
#define DEFAULT_MULTIPLIER_X 4
#define DEFAULT_MULTIPLIER_Y 8
#define DEFAULT_EXPONENT 1
#define MULTIPLIER_STEP 0.25
#define EXPONENT_STEP 0.1
#define REFRESH_PERIOD 10000 //=10ms
#define EVENT_BUFFER_SIZE 32

static int debug = 2;
int done = 0;
static double multiplier_x = DEFAULT_MULTIPLIER_X;
static double multiplier_y = DEFAULT_MULTIPLIER_Y;
static double exponent = DEFAULT_EXPONENT;
static int dead_zone_x = DEFAULT_DEAD_ZONE_X;
static int dead_zone_y = DEFAULT_DEAD_ZONE_Y;
int calibration = 0;
static int lctrl = 0;
static int rctrl = 0;

SDL_Surface *screen = NULL;

struct sixaxis_state state[MAX_CONTROLLERS];
int (*assemble)(uint8_t *buf, int len, struct sixaxis_state *state);
static int sockfd[MAX_CONTROLLERS];
s_controller controller[MAX_CONTROLLERS];

#ifdef WIN32
static void err(int eval, const char *fmt)
{
    fprintf(stderr, fmt);
    exit(eval);
}

static void warn(const char *fmt)
{
    fprintf(stderr, fmt);
}
#endif

int initialize(int width, int height, const char *title)
{
    /* Init SDL */
    if (SDL_Init(SDL_INIT_VIDEO
#ifdef JOYSTICK
    |SDL_INIT_JOYSTICK
#endif
    ) < 0)
    {
        fprintf(stderr, "Unable to init SDL: %s\n", SDL_GetError());
        return 0;
    }

#ifdef WIN32
    /* enable stdout and stderr */
    freopen( "CON", "w", stdout );
    freopen( "CON", "w", stderr );
#endif

    SDL_WM_SetCaption(title, title);

    /* Init video */
    screen = SDL_SetVideoMode(width, height, 0, SDL_HWSURFACE | SDL_ANYFORMAT);
    if (screen == NULL)
    {
        fprintf(stderr, "Unable to create video surface: %s\n", SDL_GetError());
        return 0;
    }

    //SDL_WM_GrabInput(SDL_GRAB_ON);
    SDL_ShowCursor(SDL_DISABLE);

#ifdef JOYSTICK
    SDL_JoystickOpen(0);
#endif

    return 1;
}

#define TCP_PORT 21313

int tcpconnect(void)
{
    int fd;
    int i;
    int ret = -1;
    struct sockaddr_in addr;

    for(i=0; i<MAX_CONTROLLERS; ++i)
    {

#ifdef WIN32
      WSADATA wsadata;

      if (WSAStartup(MAKEWORD(1,1), &wsadata) == SOCKET_ERROR)
        err(1, "WSAStartup");

      if ((fd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
        err(1, "socket");
#else
      if ((fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
        err(1, "socket");
#endif
      memset(&addr, 0, sizeof(addr));
      addr.sin_family = AF_INET;
      addr.sin_port = htons(TCP_PORT+i);
      addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK); //inet_addr("192.168.56.101");
      if (connect(fd, (struct sockaddr *)&addr, sizeof(addr)) < 0)
      {
        fd = 0;
        warn("can't connect to port %d", i+TCP_PORT);
      }
      else
      {
        ret = 1;
      }

#ifdef WIN32
      // Set the socket I/O mode; iMode = 0 for blocking; iMode != 0 for non-blocking
      int iMode = 1;
      ioctlsocket(fd, FIONBIO, (u_long FAR*) &iMode);
#endif

      sockfd[i] = fd;

    }

    return ret;
}

void move_x(int x)
{
    state[0].user.axis[0][0] = x;
}

void move_y(int y)
{
    state[0].user.axis[0][1] = y;
}

void circle_test()
{
  int i;
  const double pi = 3.14159265;
  const int m = 256;
  const int step = 1;
  SDL_Event event;

  for(i=1; i<360; i+=step)
  {
    event.type = SDL_MOUSEMOTION;
    event.motion.xrel = m*(cos(i*2*pi/360)-cos((i-1)*2*pi/360));
    event.motion.yrel = m*(sin(i*2*pi/360)-sin((i-1)*2*pi/360));
    SDL_PushEvent(&event);
    usleep(REFRESH_PERIOD);
  }
}

void key(int sym, int down)
{
	int index = -1;
	pthread_t thread;
  pthread_attr_t thread_attr;

//	switch (sym) {
//	case SDLK_RSHIFT:	index = sb_ps;		break;
//
//	case SDLK_e:		index = sb_triangle;	break;
//	case SDLK_SPACE:	index = sb_cross;	break;
//	case SDLK_LCTRL:	index = sb_circle;	break;
//	case SDLK_LALT:	    index = sb_r3;	break;
//	case SDLK_r:		index = sb_square;	break;
//
//	case SDLK_TAB: 		index = sb_select;	break;
//	case SDLK_BACKSPACE:    index = sb_start;	break;
//
//	case SDLK_t:        	index = sb_l2;		break;
//	case SDLK_k:        	index = sb_l1;		break;
//	case SDLK_l:        	index = sb_r1;		break;
//	case SDLK_g:	        index = sb_r2;		break;
//	case SDLK_LSHIFT:       index = sb_l3;		break;
//	case SDLK_f:	        index = sb_r3;		break;
//
//	case SDLK_AMPERSAND:	index = sb_up;		break;
//	case SDLK_WORLD_73:	 	index = sb_down;	break;
//	case SDLK_QUOTEDBL:	 	index = sb_left;	break;
//	case SDLK_QUOTE: 		index = sb_right;	break;
//
//#ifndef WIN32
//	case SDLK_q:		down?move_x(-127):move_x(0);	break;
//	case SDLK_z:	 	down?move_y(-127):move_y(0);	break;
//#else
//	case SDLK_a:		down?move_x(-127):move_x(0);	break;
//	case SDLK_w:	 	down?move_y(-127):move_y(0);	break;
//#endif
//	case SDLK_s:	 	down?move_y(127):move_y(0);	break;
//	case SDLK_d: 		down?move_x(127):move_x(0);	break;
//
//	case SDLK_RIGHT:        index = sb_right;	break;
//	case SDLK_LEFT:         index = sb_left;	break;
//	case SDLK_UP:           index = sb_cross;	break;
//	case SDLK_DOWN:         index = sb_circle;	break;
//	}

	switch (sym)
  {
	  case SDLK_LCTRL: lctrl = down ? 1 : 0; break;
    case SDLK_RCTRL: rctrl = down ? 1 : 0; break;

    case SDLK_p:
    if(down && lctrl)
      {
        pthread_attr_init(&thread_attr);
        pthread_attr_setdetachstate(&thread_attr, PTHREAD_CREATE_DETACHED);
        pthread_create( &thread, &thread_attr, (void*)circle_test, NULL);
      }
      break;

    case SDLK_ESCAPE: if(down) done = 1; break;
  }

	if(calibration)
	{
	  switch (sym)
	  {
	    case SDLK_KP_MINUS: if(down) { multiplier_x -= MULTIPLIER_STEP; printf("multiplier_x: %e\n", multiplier_x); } break;
	    case SDLK_KP_PLUS:  if(down) { multiplier_x += MULTIPLIER_STEP; printf("multiplier_x: %e\n", multiplier_x); } break;
	    case SDLK_KP9: if(down) { multiplier_y -= MULTIPLIER_STEP; printf("multiplier_y: %e\n", multiplier_y); } break;
	    case SDLK_KP6:  if(down) { multiplier_y += MULTIPLIER_STEP; printf("multiplier_y: %e\n", multiplier_y); } break;
	    case SDLK_KP_DIVIDE:  if(down) { dead_zone_x -= 1; printf("dead_zone_x: %d\n", dead_zone_x); } break;
	    case SDLK_KP_MULTIPLY:  if(down) { dead_zone_x += 1; printf("dead_zone_x: %d\n", dead_zone_x); } break;
	    case SDLK_KP2:  if(down) { dead_zone_y -= 1; printf("dead_zone_y: %d\n", dead_zone_y); } break;
	    case SDLK_KP3:  if(down) { dead_zone_y += 1; printf("dead_zone_y: %d\n", dead_zone_y); } break;
	    case SDLK_KP7:  if(down) { exponent -= EXPONENT_STEP; printf("exponent: %e\n", exponent); } break;
	    case SDLK_KP8:  if(down) { exponent += EXPONENT_STEP; printf("exponent: %e\n", exponent); } break;
	  }
	}

	if(lctrl && rctrl)
  {
    if(calibration)
    {
      calibration = 0;
      printf("calibration mode disabled\n");
    }
    else
    {
      calibration = 1;
      printf("calibration mode enabled\n");
    }
  }

	if(down) macro_lookup(sym);

	if (index >= 0) {
		state[0].user.button[index].pressed = down ? 1 : 0;
		state[0].user.button[index].value = down ? 255 : 0;
	}
}

void clic(int button, int down)
{
    int index = -1;

	switch(button)
	{
	case SDL_BUTTON_LEFT: 		index = sb_r1; 			break;
	case SDL_BUTTON_RIGHT: 		index = sb_l1; 			break;
	case SDL_BUTTON_MIDDLE: 	index = sb_triangle; 	break;
	case SDL_BUTTON_WHEELUP: 	index = sb_r2; 			break;
	case SDL_BUTTON_WHEELDOWN: 	index = sb_l2; 			break;
	case SDL_BUTTON_X1:			index = sb_square; 		break;
	case SDL_BUTTON_X2: 		index = sb_r3; 			break;
	case 8: 	                index = sb_triangle; 	break; //Logitech G5 side button
	}

    if (index >= 0) {
        state[0].user.button[index].pressed = down ? 1 : 0;
        state[0].user.button[index].value = down ? 255 : 0;
    }
}

#ifdef JOYSTICK
void process_joystick_event(SDL_Event* event)
{
    int index;

    switch(event->type)
    {
        case SDL_JOYAXISMOTION:

            if(event->jaxis.axis == 0)
            {
                state[0].user.axis[0][0] = event->jaxis.value/96;
            }
            else if(event->jaxis.axis == 1)
            {
                if(event->jaxis.value/128 > 16)
                {
                    state[0].user.button[sb_l2].pressed = 1;
                    state[0].user.button[sb_l2].value = clamp(0, event->jaxis.value/96, 255);
                }
                else if(event->jaxis.value/128 < -16)
                {
                    state[0].user.button[sb_r2].pressed = 1;
                    state[0].user.button[sb_r2].value = clamp(0, -event->jaxis.value/96, 255);
                }
                else
                {
                    state[0].user.button[sb_l2].pressed = 0;
                    state[0].user.button[sb_l2].value = 0;
                    state[0].user.button[sb_r2].pressed = 0;
                    state[0].user.button[sb_r2].value = 0;
                }
            }
            break;

        case SDL_JOYBUTTONDOWN:

            index = -1;
            switch(event->jbutton.button)
            {
            case 0:
                index = sb_l1;
                break;
            case 1:
                index = sb_circle;
                break;
            case 2:
                index = sb_triangle;
                break;
            case 3:
                index = sb_cross;
                break;
            case 4:
                index = sb_square;
                break;
            case 5:
                index = sb_up;
                break;
            }
            if(index >= 0)
            {
                state[0].user.button[index].pressed = 1;
                state[0].user.button[index].value = 255;
            }
            break;

        case SDL_JOYBUTTONUP:

            index = -1;
            switch(event->jbutton.button)
            {
            case 0:
                index = sb_l1;
                break;
            case 1:
                index = sb_circle;
                break;
            case 2:
                index = sb_triangle;
                break;
            case 3:
                index = sb_cross;
                break;
            case 4:
                index = sb_square;
                break;
            case 5:
                index = sb_up;
                break;
            }
            if(index >= 0)
            {
                state[0].user.button[index].pressed = 0;
                state[0].user.button[index].value = 0;
            }
            break;
    }
}
#endif

/*
 * to be deleted later
 */
extern s_mouse_control mouse_control[MAX_DEVICES];

int main(int argc, char *argv[])
{
    SDL_Event events[EVENT_BUFFER_SIZE];
    SDL_Event* event;
    SDL_Event mouse_raz;
    int i;
    int num_evt;
    unsigned char buf[48];

    //init_config();

    read_config_dir();

    initialize_macros();

    for(i=0; i<MAX_CONTROLLERS; ++i)
    {
      sixaxis_init(state+i);
      memset(controller+i, 0x00, sizeof(s_controller));
    }

    if (!initialize(SCREEN_WIDTH, SCREEN_HEIGHT, "Sixaxis Control"))
        err(1, "can't init sdl");

    if(tcpconnect() < 0)
    {
      err(1, "tcpconnect");
    }

    done = 0;
    while(!done)
    {
        SDL_PumpEvents();
        num_evt = SDL_PeepEvents(events, sizeof(events)/sizeof(events[0]), SDL_GETEVENT, SDL_ALLEVENTS);
        if(num_evt > 0)
        {
          controller[0].change = 1;
          controller[0].send_command = 1;

          for(event=events; event<events+num_evt; ++event)
          {
              process_event(event);

              trigger_lookup(event);

              /*
               * to remove: beg
               */
//
              switch( event->type ) {
//#ifdef JOYSTICK
//              case SDL_JOYAXISMOTION:
//              case SDL_JOYBUTTONDOWN:
//              case SDL_JOYBUTTONUP:
//                  process_joystick_event(event);
//                  break;
//#endif
              case SDL_QUIT:
                  done = 1;
                  break;
              case SDL_KEYDOWN:
                key(event->key.keysym.sym, 1);
                break;
              case SDL_KEYUP:
                  key(event->key.keysym.sym, 0);
                  break;
//              case SDL_MOUSEMOTION:
//                //printf("%d\n", event->motion.xrel);
//                mouse_control[0].merge_x += multiplier_x*event->motion.xrel;
//                mouse_control[0].merge_y += multiplier_y*event->motion.yrel;
//                mouse_control[0].nb_motion++;
//                  cpt = 0;
//                  break;
//              case SDL_MOUSEBUTTONDOWN:
//                  clic(event->button.button, 1);
//                  break;
//              case SDL_MOUSEBUTTONUP:
//                  if(event->button.button == SDL_BUTTON_WHEELUP)
//                  {
//                      if(mouse_control[0].postpone_wheel_up < POSTPONE_COUNT)
//                      {
//                          SDL_PushEvent(event);
//                          mouse_control[0].postpone_wheel_up++;
//                      }
//                      else
//                      {
//                        mouse_control[0].postpone_wheel_up = 0;
//                          clic(event->button.button, 0);
//                      }
//                  }
//                  else if(event->button.button == SDL_BUTTON_WHEELDOWN)
//                  {
//                      if(mouse_control[0].postpone_wheel_down < POSTPONE_COUNT)
//                      {
//                          SDL_PushEvent(event);
//                          mouse_control[0].postpone_wheel_down++;
//                      }
//                      else
//                      {
//                        mouse_control[0].postpone_wheel_down = 0;
//                          clic(event->button.button, 0);
//                      }
//                  }
//                  else if(event->button.button == SDL_BUTTON_X1)
//                  {
//                      if(mouse_control[0].postpone_button_x1 < POSTPONE_COUNT)
//                      {
//                          SDL_PushEvent(event);
//                          mouse_control[0].postpone_button_x1++;
//                      }
//                      else
//                      {
//                        mouse_control[0].postpone_button_x1 = 0;
//                          clic(event->button.button, 0);
//                      }
//                  }
//                  else if(event->button.button == SDL_BUTTON_X2)
//                  {
//                      if(mouse_control[0].postpone_button_x2 < POSTPONE_COUNT)
//                      {
//                          SDL_PushEvent(event);
//                          mouse_control[0].postpone_button_x2++;
//                      }
//                      else
//                      {
//                        mouse_control[0].postpone_button_x2 = 0;
//                          clic(event->button.button, 0);
//                      }
//                  }
//                  else
//                  {
//                      clic(event->button.button, 0);
//                  }
//                  break;
              }
              /*
               * to remove: end
               */


          }
        }

        for(i=0; i<MAX_DEVICES; ++i)
        {
          if(mouse_control[i].changed)
          {
            if(!mouse_control[i].nb_motion)
            {
              mouse_raz.motion.which = i;
              mouse_raz.type = SDL_MOUSEMOTION;
              mouse_raz.motion.xrel = 0;
              mouse_raz.motion.yrel = 0;
              process_event(&mouse_raz);
              mouse_control[i].changed = 0;
            }
          }
          mouse_control[i].merge_x = 0;
          mouse_control[i].merge_y = 0;
          mouse_control[i].nb_motion = 0;
        }

        for(i=0; i<MAX_CONTROLLERS; ++i)
        {
          if(controller[i].send_command)
          {
            if (assemble_input_01(buf, sizeof(buf), state+i) < 0)
            {
              printf("can't assemble\n");
            }

            send(sockfd[i], buf, 48, MSG_DONTWAIT);

            if (debug)
            {
              sixaxis_dump_state(state+i);
            }

            controller[i].send_command = 0;
          }
        }
        usleep(REFRESH_PERIOD);
    }

    printf("Exiting\n");
    SDL_Quit();

    free_macros();

    return 0;
}
